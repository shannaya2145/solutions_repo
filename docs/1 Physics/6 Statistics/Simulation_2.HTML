<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monte Carlo π Estimation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        canvas {
            border: 1px solid black;
            margin: 10px;
            background-color: white;
        }
        h2, h3 {
            color: #333;
        }
        .formula {
            background-color: #fff;
            padding: 10px;
            border: 1px solid #ccc;
            margin: 10px;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <h2>Monte Carlo Estimation of π</h2>
    
    <h3>Circle Method Formulas</h3>
    <div class="formula">
        Area of circle: \( A_{\text{circle}} = \pi r^2 = \pi \) (r = 1)<br>
        Area of square: \( A_{\text{square}} = 2 \cdot 2 = 4 \)<br>
        Ratio: \( \frac{A_{\text{circle}}}{A_{\text{square}}} = \frac{\pi}{4} \)<br>
        Estimate: \( \pi \approx 4 \cdot \frac{N_{\text{circle}}}{N} \)
    </div>
    
    <h3>Buffon’s Needle Formulas</h3>
    <div class="formula">
        Crossing condition: \( x \leq \frac{l}{2} \sin(\theta) \), where \( l = 1 \), \( d = 1 \)<br>
        Probability: \( P(\text{cross}) = \frac{2l}{\pi d} = \frac{2}{\pi} \)<br>
        Estimate: \( \pi \approx \frac{2N}{N_{\text{cross}}} \)
    </div>
    
    <h3>Central Limit Theorem</h3>
    <div class="formula">
        Sampling distribution: \( \bar{\pi} \sim \mathcal{N}\left(\pi, \frac{\sigma^2}{n}\right) \)<br>
        Variance (circle): \( \text{Var}(\hat{\pi}) = \frac{4\pi (4 - \pi)}{N} \)
    </div>

    <script>
        let circlePoints = [];
        let circleInsideCount = 0;
        let circleTotalCount = 0;
        let circlePiEstimates = [];
        let needlePoints = [];
        let needleCrossCount = 0;
        let needleTotalCount = 0;
        let needlePiEstimates = [];
        const maxPoints = 10000;
        const truePi = Math.PI;
        let cltEstimates = [];
        const cltTrials = 100;
        const cltSampleSize = 1000;

        function setup() {
            // Create three canvases
            let canvas1 = createCanvas(400, 400); // Circle method
            canvas1.parent('body');
            let canvas2 = createCanvas(400, 200); // Buffon's Needle
            canvas2.parent('body');
            let canvas3 = createCanvas(400, 400); // Convergence and CLT
            canvas3.parent('body');
            
            // Run CLT trials
            for (let i = 0; i < cltTrials; i++) {
                let inside = 0;
                for (let j = 0; j < cltSampleSize; j++) {
                    let x = random(-1, 1);
                    let y = random(-1, 1);
                    if (x * x + y * y <= 1) inside++;
                }
                cltEstimates.push(4 * inside / cltSampleSize);
            }
        }

        function draw() {
            // --- Circle Method Canvas ---
            select('canvas', document.body.children[5]).elt.getContext('2d').save();
            background(255);
            stroke(0);
            noFill();
            ellipse(200, 200, 200, 200); // Unit circle
            if (circleTotalCount < maxPoints) {
                let x = random(-1, 1);
                let y = random(-1, 1);
                let isInside = (x * x + y * y) <= 1;
                circlePoints.push({x: x, y: y, inside: isInside});
                circleTotalCount++;
                if (isInside) circleInsideCount++;
                let piEstimate = 4 * circleInsideCount / circleTotalCount;
                circlePiEstimates.push(piEstimate);
            }
            circlePoints.forEach(p => {
                stroke(p.inside ? [0, 0, 255] : [255, 0, 0]);
                point(200 + p.x * 100, 200 - p.y * 100);
            });
            fill(0);
            noStroke();
            textSize(16);
            let circlePi = circleTotalCount > 0 ? 4 * circleInsideCount / circleTotalCount : 0;
            text(`Circle: N = ${circleTotalCount}`, 10, 20);
            text(`π ≈ ${circlePi.toFixed(4)}`, 10, 40);
            text(`Error = ${Math.abs(circlePi - truePi).toFixed(4)}`, 10, 60);

            // --- Buffon's Needle Canvas ---
            select('canvas', document.body.children[6]).elt.getContext('2d').save();
            background(255);
            if (needleTotalCount < maxPoints) {
                let x = random(0, 0.5);
                let theta = random(0, PI);
                let crosses = x <= 0.5 * Math.sin(theta);
                needlePoints.push({x: x, theta: theta, crosses: crosses});
                needleTotalCount++;
                if (crosses) needleCrossCount++;
                let piEstimate = needleCrossCount > 0 ? 2 * needleTotalCount / needleCrossCount : 0;
                needlePiEstimates.push(piEstimate);
            }
            for (let line = 0; line <= 1; line++) {
                stroke(0);
                line(line * 200, 0, line * 200, 200);
            }
            needlePoints.slice(-50).forEach(p => {
                let x_center = p.x * 200;
                let angle = p.theta;
                let x_ends = [x_center - 100 * Math.cos(angle), x_center + 100 * Math.cos(angle)];
                let y_ends = [100 * Math.sin(angle), -100 * Math.sin(angle)];
                stroke(p.crosses ? [0, 0, 255] : [255, 0, 0]);
                line(x_ends[0] + 200, y_ends[0] + 100, x_ends[1] + 200, y_ends[1] + 100);
            });
            fill(0);
            noStroke();
            textSize(16);
            let needlePi = needleCrossCount > 0 ? 2 * needleTotalCount / needleCrossCount : 0;
            text(`Needle: N = ${needleTotalCount}`, 10, 20);
            text(`π ≈ ${needlePi.toFixed(4)}`, 10, 40);
            text(`Error = ${Math.abs(needlePi - truePi).toFixed(4)}`, 10, 60);

            // --- Convergence and CLT Canvas ---
            select('canvas', document.body.children[7]).elt.getContext('2d').save();
            background(255);
            
            // Convergence plot (top half)
            stroke(0);
            noFill();
            beginShape();
            for (let i = 0; i < circlePiEstimates.length; i++) {
                let x = map(i, 0, maxPoints, 0, 400);
                let y = map(circlePiEstimates[i], 2.5, 4, 200, 0);
                vertex(x, y);
            }
            endShape();
            stroke(255, 0, 0);
            beginShape();
            for (let i = 0; i < needlePiEstimates.length; i++) {
                let x = map(i, 0, maxPoints, 0, 400);
                let y = map(needlePiEstimates[i], 2.5, 4, 200, 0);
                vertex(x, y);
            }
            endShape();
            stroke(0, 0, 255);
            let yPi = map(truePi, 2.5, 4, 200, 0);
            line(0, yPi, 400, yPi);
            stroke(0);
            line(0, 200, 400, 200); // x-axis
            line(0, 0, 0, 200); // y-axis
            textSize(12);
            fill(0);
            text('N', 380, 190);
            text('π', 10, 10);
            text('2.5', 10, 190);
            text('4.0', 10, 30);

            // CLT histogram (bottom half)
            let bins = 20;
            let hist = new Array(bins).fill(0);
            let minPi = Math.min(...cltEstimates);
            let maxPi = Math.max(...cltEstimates);
            cltEstimates.forEach(pi => {
                let bin = Math.floor(map(pi, minPi, maxPi, 0, bins));
                if (bin >= 0 && bin < bins) hist[bin]++;
            });
            let maxHeight = Math.max(...hist);
            for (let i = 0; i < bins; i++) {
                let x = map(i, 0, bins, 0, 400);
                let h = map(hist[i], 0, maxHeight, 0, 150);
                fill(100, 100, 255, 150);
                noStroke();
                rect(x, 400 - h, 400 / bins, h);
            }
            stroke(0);
            line(0, 400, 400, 400); // x-axis
            line(0, 250, 0, 400); // y-axis
            text('π Estimates', 350, 390);
            text('Count', 10, 260);

            // Restore contexts
            select('canvas', document.body.children[5]).elt.getContext('2d').restore();
            select('canvas', document.body.children[6]).elt.getContext('2d').restore();
            select('canvas', document.body.children[7]).elt.getContext('2d').restore();

            // Stop after maxPoints
            if (circleTotalCount >= maxPoints && needleTotalCount >= maxPoints) {
                noLoop();
            }
        }
    </script>
</body>
</html>