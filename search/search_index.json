{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Simulation Investigating the Range as a Function of the Angle of Projection Projectile motion is a classic problem in physics that combines simplicity with profound insights. Here, we analyze how the horizontal range of a projectile depends on its launch angle, derive the governing equations, explore parameter variations, and simulate the results computationally. 1. Theoretical Foundation Deriving the Equations of Motion Projectile motion occurs under constant gravitational acceleration, with no initial forces other than the launch impulse. Assuming a flat surface and neglecting air resistance, we start with Newton\u2019s second law in two dimensions (horizontal \\(x\\) and vertical \\(y\\) ): Horizontal motion : No acceleration ( \\(a_x = 0\\) ). $$ \\frac{d^2 x}{dt^2} = 0 $$ Initial conditions: \\(x(0) = 0\\) , \\(\\frac{dx}{dt}(0) = v_0 \\cos\\theta\\) , where \\(v_0\\) is the initial velocity and \\(\\theta\\) is the angle of projection. Solving: $$ x(t) = v_0 \\cos\\theta \\cdot t $$ Vertical motion : Constant acceleration ( \\(a_y = -g\\) ), where \\(g\\) is gravitational acceleration. $$ \\frac{d^2 y}{dt^2} = -g $$ Initial conditions: \\(y(0) = 0\\) , \\(\\frac{dy}{dt}(0) = v_0 \\sin\\theta\\) . Integrating twice: $$ \\frac{dy}{dt} = v_0 \\sin\\theta - g t $$ $$ y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$ These equations describe a parabolic trajectory, parameterized by \\(v_0\\) , \\(\\theta\\) , and \\(g\\) . Family of Solutions The solutions form a family parameterized by initial conditions: - \\(v_0\\) : Higher velocities stretch the parabola. - \\(\\theta\\) : Angles shift the balance between horizontal and vertical components. - \\(g\\) : Stronger gravity compresses the trajectory vertically. - Initial height ( \\(h\\) ): If \\(y(0) = h\\) , the equations adjust, affecting flight time and range. 2. Analysis of the Range Range as a Function of Angle The range \\(R\\) is the horizontal distance traveled when the projectile returns to \\(y = 0\\) . Set \\(y(t) = 0\\) : $$ 0 = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$ Factor out \\(t\\) : $$ t (v_0 \\sin\\theta - \\frac{1}{2} g t) = 0 $$ Solutions: \\(t = 0\\) (start) or \\(t = \\frac{2 v_0 \\sin\\theta}{g}\\) (landing time). Substitute into \\(x(t)\\) : $$ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} = \\frac{2 v_0^2 \\sin\\theta \\cos\\theta}{g} $$ Using the identity \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) : $$ R = \\frac{v_0^2 \\sin 2\\theta}{g} $$ - Maximum Range : \\(R\\) peaks when \\(\\sin 2\\theta = 1\\) , i.e., \\(2\\theta = 90^\\circ\\) , so \\(\\theta = 45^\\circ\\) . Then, \\(R_{\\text{max}} = \\frac{v_0^2}{g}\\) . - Symmetry : \\(\\theta\\) and \\(90^\\circ - \\theta\\) yield the same range (e.g., 30\u00b0 and 60\u00b0). Influence of Parameters Initial Velocity ( \\(v_0\\) ) : Range scales with \\(v_0^2\\) , amplifying the effect of angle. Gravity ( \\(g\\) ) : Higher \\(g\\) reduces \\(R\\) , compressing the trajectory. Launch Height : If \\(h > 0\\) , flight time increases, extending \\(R\\) . This requires solving a quadratic equation for \\(t\\) . 3. Practical Applications Sports : Optimizing a basketball shot or golf swing involves angle and velocity tuning. Engineering : Artillery and rocket launches adjust for terrain and air resistance. Astrophysics : Trajectories on other planets (different \\(g\\) ) follow the same principles. Uneven Terrain : Adjust the landing condition (e.g., \\(y = h_2\\) ) to model hills. Air Resistance : Introduce a drag term (proportional to velocity squared), requiring numerical solutions. 4. Implementation Below is a Python script to simulate and visualize the range versus angle: import numpy as np import matplotlib.pyplot as plt def calculate_range(v0, theta_deg, g=9.81, h=0): \"\"\"Calculate range given initial velocity, angle (degrees), gravity, and height.\"\"\" theta = np.radians(theta_deg) if h == 0: return (v0**2 * np.sin(2 * theta)) / g else: # For h > 0, solve quadratic for time: 0 = h + v0*sin(theta)*t - (1/2)*g*t^2 a = -0.5 * g b = v0 * np.sin(theta) c = h t = (-b + np.sqrt(b**2 - 4*a*c)) / (2*a) # Positive root return v0 * np.cos(theta) * t # Parameters v0_values = [10, 15, 20] # m/s g_values = [9.81, 3.71] # Earth, Mars h_values = [0, 5] # m angles = np.linspace(0, 90, 91) # 0\u00b0 to 90\u00b0 # Plotting plt.figure(figsize=(12, 8)) for v0 in v0_values: for g in g_values: for h in h_values: ranges = [calculate_range(v0, theta, g, h) for theta in angles] label = f\"v0={v0} m/s, g={g} m/s\u00b2, h={h} m\" plt.plot(angles, ranges, label=label) plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (meters)\") plt.title(\"Range vs. Angle of Projection\") plt.legend() plt.grid(True) plt.show() Output This generates a plot showing \\(R\\) versus \\(\\theta\\) for different \\(v_0\\) , \\(g\\) , and \\(h\\) . Key observations: - Peak at 45\u00b0 for \\(h = 0\\) . - Higher \\(v_0\\) increases range quadratically. - Lower \\(g\\) (e.g., Mars) extends range. - Non-zero \\(h\\) shifts the optimal angle below 45\u00b0. Limitations and Extensions Idealized Model : Assumes no air resistance, flat terrain, and constant \\(g\\) . Drag : Add \\(-k v^2\\) terms to the differential equations, solved numerically (e.g., Runge-Kutta). Wind : Introduce a velocity-dependent force. Terrain : Model \\(y_{\\text{ground}}(x)\\) and solve numerically for landing. Conclusion The range\u2019s dependence on \\(\\theta\\) reveals a beautiful symmetry and optimization problem, with \\(45^\\circ\\) as the sweet spot under ideal conditions. Variations in parameters enrich the model, bridging theory to real-world applications. The simulation highlights these relationships vividly, inviting further exploration into complex scenarios.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Simulation","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"Projectile motion is a classic problem in physics that combines simplicity with profound insights. Here, we analyze how the horizontal range of a projectile depends on its launch angle, derive the governing equations, explore parameter variations, and simulate the results computationally.","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deriving-the-equations-of-motion","text":"Projectile motion occurs under constant gravitational acceleration, with no initial forces other than the launch impulse. Assuming a flat surface and neglecting air resistance, we start with Newton\u2019s second law in two dimensions (horizontal \\(x\\) and vertical \\(y\\) ): Horizontal motion : No acceleration ( \\(a_x = 0\\) ). $$ \\frac{d^2 x}{dt^2} = 0 $$ Initial conditions: \\(x(0) = 0\\) , \\(\\frac{dx}{dt}(0) = v_0 \\cos\\theta\\) , where \\(v_0\\) is the initial velocity and \\(\\theta\\) is the angle of projection. Solving: $$ x(t) = v_0 \\cos\\theta \\cdot t $$ Vertical motion : Constant acceleration ( \\(a_y = -g\\) ), where \\(g\\) is gravitational acceleration. $$ \\frac{d^2 y}{dt^2} = -g $$ Initial conditions: \\(y(0) = 0\\) , \\(\\frac{dy}{dt}(0) = v_0 \\sin\\theta\\) . Integrating twice: $$ \\frac{dy}{dt} = v_0 \\sin\\theta - g t $$ $$ y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$ These equations describe a parabolic trajectory, parameterized by \\(v_0\\) , \\(\\theta\\) , and \\(g\\) .","title":"Deriving the Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"The solutions form a family parameterized by initial conditions: - \\(v_0\\) : Higher velocities stretch the parabola. - \\(\\theta\\) : Angles shift the balance between horizontal and vertical components. - \\(g\\) : Stronger gravity compresses the trajectory vertically. - Initial height ( \\(h\\) ): If \\(y(0) = h\\) , the equations adjust, affecting flight time and range.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-as-a-function-of-angle","text":"The range \\(R\\) is the horizontal distance traveled when the projectile returns to \\(y = 0\\) . Set \\(y(t) = 0\\) : $$ 0 = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$ Factor out \\(t\\) : $$ t (v_0 \\sin\\theta - \\frac{1}{2} g t) = 0 $$ Solutions: \\(t = 0\\) (start) or \\(t = \\frac{2 v_0 \\sin\\theta}{g}\\) (landing time). Substitute into \\(x(t)\\) : $$ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} = \\frac{2 v_0^2 \\sin\\theta \\cos\\theta}{g} $$ Using the identity \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) : $$ R = \\frac{v_0^2 \\sin 2\\theta}{g} $$ - Maximum Range : \\(R\\) peaks when \\(\\sin 2\\theta = 1\\) , i.e., \\(2\\theta = 90^\\circ\\) , so \\(\\theta = 45^\\circ\\) . Then, \\(R_{\\text{max}} = \\frac{v_0^2}{g}\\) . - Symmetry : \\(\\theta\\) and \\(90^\\circ - \\theta\\) yield the same range (e.g., 30\u00b0 and 60\u00b0).","title":"Range as a Function of Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-parameters","text":"Initial Velocity ( \\(v_0\\) ) : Range scales with \\(v_0^2\\) , amplifying the effect of angle. Gravity ( \\(g\\) ) : Higher \\(g\\) reduces \\(R\\) , compressing the trajectory. Launch Height : If \\(h > 0\\) , flight time increases, extending \\(R\\) . This requires solving a quadratic equation for \\(t\\) .","title":"Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Optimizing a basketball shot or golf swing involves angle and velocity tuning. Engineering : Artillery and rocket launches adjust for terrain and air resistance. Astrophysics : Trajectories on other planets (different \\(g\\) ) follow the same principles. Uneven Terrain : Adjust the landing condition (e.g., \\(y = h_2\\) ) to model hills. Air Resistance : Introduce a drag term (proportional to velocity squared), requiring numerical solutions.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Below is a Python script to simulate and visualize the range versus angle: import numpy as np import matplotlib.pyplot as plt def calculate_range(v0, theta_deg, g=9.81, h=0): \"\"\"Calculate range given initial velocity, angle (degrees), gravity, and height.\"\"\" theta = np.radians(theta_deg) if h == 0: return (v0**2 * np.sin(2 * theta)) / g else: # For h > 0, solve quadratic for time: 0 = h + v0*sin(theta)*t - (1/2)*g*t^2 a = -0.5 * g b = v0 * np.sin(theta) c = h t = (-b + np.sqrt(b**2 - 4*a*c)) / (2*a) # Positive root return v0 * np.cos(theta) * t # Parameters v0_values = [10, 15, 20] # m/s g_values = [9.81, 3.71] # Earth, Mars h_values = [0, 5] # m angles = np.linspace(0, 90, 91) # 0\u00b0 to 90\u00b0 # Plotting plt.figure(figsize=(12, 8)) for v0 in v0_values: for g in g_values: for h in h_values: ranges = [calculate_range(v0, theta, g, h) for theta in angles] label = f\"v0={v0} m/s, g={g} m/s\u00b2, h={h} m\" plt.plot(angles, ranges, label=label) plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (meters)\") plt.title(\"Range vs. Angle of Projection\") plt.legend() plt.grid(True) plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#output","text":"This generates a plot showing \\(R\\) versus \\(\\theta\\) for different \\(v_0\\) , \\(g\\) , and \\(h\\) . Key observations: - Peak at 45\u00b0 for \\(h = 0\\) . - Higher \\(v_0\\) increases range quadratically. - Lower \\(g\\) (e.g., Mars) extends range. - Non-zero \\(h\\) shifts the optimal angle below 45\u00b0.","title":"Output"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-and-extensions","text":"Idealized Model : Assumes no air resistance, flat terrain, and constant \\(g\\) . Drag : Add \\(-k v^2\\) terms to the differential equations, solved numerically (e.g., Runge-Kutta). Wind : Introduce a velocity-dependent force. Terrain : Model \\(y_{\\text{ground}}(x)\\) and solve numerically for landing.","title":"Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The range\u2019s dependence on \\(\\theta\\) reveals a beautiful symmetry and optimization problem, with \\(45^\\circ\\) as the sweet spot under ideal conditions. Variations in parameters enrich the model, bridging theory to real-world applications. The simulation highlights these relationships vividly, inviting further exploration into complex scenarios.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Simulation Investigating the Dynamics of a Forced Damped Pendulum The forced damped pendulum is a classic nonlinear system that exhibits a wide range of behaviors\u2014from simple oscillations to chaos\u2014due to the interplay of damping, gravitational restoring forces, and external periodic driving. This exploration bridges fundamental physics with computational modeling, offering insights into both theoretical principles and real-world applications. 1. Theoretical Foundation Governing Differential Equation The motion of a forced damped pendulum is described by a second-order nonlinear differential equation: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = F \\cos(\\omega_d t) $$ Where: - \\(\\theta\\) : Angular displacement (radians). - \\(b\\) : Damping coefficient (s\u207b\u00b9). - \\(g\\) : Gravitational acceleration (m/s\u00b2). - \\(L\\) : Pendulum length (m). - \\(F\\) : Driving force amplitude (s\u207b\u00b2). - \\(\\omega_d\\) : Driving frequency (rad/s). This equation balances angular acceleration, viscous damping, gravitational restoring force, and periodic forcing. Small-Angle Approximation For small \\(\\theta\\) , \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to a linear forced damped oscillator: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = F \\cos(\\omega_d t) $$ Where \\(\\omega_0 = \\sqrt{g/L}\\) is the natural frequency. The general solution is: - Homogeneous : \\(\\theta_h(t) = A e^{-\\frac{b}{2}t} \\cos(\\omega t + \\phi)\\) , with \\(\\omega = \\sqrt{\\omega_0^2 - (b/2)^2}\\) (underdamped case). Particular : \\(\\theta_p(t) = A_d \\cos(\\omega_d t - \\delta)\\) , where: $$ A_d = \\frac{F}{\\sqrt{(\\omega_0^2 - \\omega_d^2)^2 + (b \\omega_d)^2}}, \\quad \\delta = \\tan^{-1}\\left(\\frac{b \\omega_d}{\\omega_0^2 - \\omega_d^2}\\right) $$ Total : \\(\\theta(t) = \\theta_h(t) + \\theta_p(t)\\) . The transient ( \\(\\theta_h\\) ) decays, leaving the steady-state oscillation. Resonance Resonance occurs when \\(\\omega_d \\approx \\omega_0\\) , maximizing \\(A_d\\) . For light damping ( \\(b \\ll \\omega_0\\) ), the amplitude peaks sharply, amplifying energy input from the driving force. 2. Analysis of Dynamics Parameter Influence Damping ( \\(b\\) ) : Reduces amplitude and prevents unbounded growth at resonance. High \\(b\\) can suppress chaos. Driving Amplitude ( \\(F\\) ) : Small \\(F\\) yields periodic motion; large \\(F\\) can drive the system into chaos. Driving Frequency ( \\(\\omega_d\\) ) : Near \\(\\omega_0\\) , resonance amplifies motion. Far from \\(\\omega_0\\) , motion may become quasiperiodic or chaotic. Transition to Chaos Beyond small angles, the \\(\\sin\\theta\\) nonlinearity introduces complex dynamics: - Periodic Motion : At low \\(F\\) or \\(\\omega_d \\approx \\omega_0\\) , motion synchronizes with the drive. - Quasiperiodic Motion : Multiple incommensurate frequencies emerge as \\(F\\) increases. - Chaotic Motion : High \\(F\\) and specific \\(\\omega_d\\) lead to unpredictable, aperiodic behavior, sensitive to initial conditions. 3. Practical Applications Energy Harvesting : Oscillatory motion in piezoelectric devices converts mechanical energy to electricity. Suspension Bridges : External forces (wind) can induce resonant or chaotic vibrations, informing design. Circuits : Driven RLC circuits mirror this system, aiding oscillator design. 4. Implementation Python Simulation Below is a Python script using the Runge-Kutta (RK4) method to solve the nonlinear equation and visualize the dynamics: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # m/s\u00b2 L = 1.0 # m omega0 = np.sqrt(g / L) # Differential equation def pendulum(t, y, b, F, omega_d): theta, theta_dot = y return [theta_dot, -b * theta_dot - (g / L) * np.sin(theta) + F * np.cos(omega_d * t)] # Simulation function def simulate_pendulum(b, F, omega_d, t_max=50, theta0=0.1, theta_dot0=0): t_span = (0, t_max) t_eval = np.linspace(0, t_max, 1000) sol = solve_ivp(pendulum, t_span, [theta0, theta_dot0], args=(b, F, omega_d), method='RK45', t_eval=t_eval, rtol=1e-6) return sol.t, sol.y[0], sol.y[1] # Poincar\u00e9 section def poincare_section(t, theta, theta_dot, omega_d): period = 2 * np.pi / omega_d indices = np.where(np.mod(t, period) < 0.01)[0] # Sample at drive phase return theta[indices], theta_dot[indices] # Plotting plt.figure(figsize=(15, 10)) # Cases to explore cases = [ {\"b\": 0.1, \"F\": 0.5, \"omega_d\": omega0, \"label\": \"Resonance\"}, {\"b\": 0.5, \"F\": 1.2, \"omega_d\": 1.2, \"label\": \"Moderate Forcing\"}, {\"b\": 0.2, \"F\": 1.5, \"omega_d\": 1.4, \"label\": \"Chaotic\"} ] for i, case in enumerate(cases, 1): t, theta, theta_dot = simulate_pendulum(case[\"b\"], case[\"F\"], case[\"omega_d\"]) # Time series plt.subplot(3, 3, i) plt.plot(t, theta, 'b-', lw=1) plt.title(f\"{case['label']} (b={case['b']}, F={case['F']}, \u03c9d={case['omega_d']:.1f})\") plt.xlabel(\"Time (s)\") plt.ylabel(\"\u03b8 (rad)\") # Phase portrait plt.subplot(3, 3, i + 3) plt.plot(theta, theta_dot, 'r-', lw=0.5) plt.title(\"Phase Portrait\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") # Poincar\u00e9 section theta_p, theta_dot_p = poincare_section(t, theta, theta_dot, case[\"omega_d\"]) plt.subplot(3, 3, i + 6) plt.scatter(theta_p, theta_dot_p, s=5, c='k') plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") plt.tight_layout() plt.show() Output Description Time Series : Shows \\(\\theta(t)\\) for resonance (periodic), moderate forcing (quasiperiodic), and chaotic motion. Phase Portraits : Plots \\(\\theta\\) vs. \\(\\dot{\\theta}\\) , revealing closed loops (periodic), layered patterns (quasiperiodic), or dense filling (chaotic). Poincar\u00e9 Sections : Samples at the driving period, showing points clustering (periodic), forming curves (quasiperiodic), or scattering (chaotic). Deliverables General Solutions Small Angles : Linear solution with decaying transient and steady-state oscillation. Nonlinear : Numerical solutions reveal periodic, quasiperiodic, or chaotic regimes depending on parameters. Graphical Representations Resonance ( \\(b=0.1, F=0.5, \\omega_d=\\omega_0\\) ) : Large, stable oscillations. Moderate Forcing ( \\(b=0.5, F=1.2, \\omega_d=1.2\\) ) : Complex but bounded motion. Chaotic ( \\(b=0.2, F=1.5, \\omega_d=1.4\\) ) : erratic, unpredictable swings. Limitations and Extensions Limitations : Assumes constant \\(b\\) , periodic forcing, and no friction irregularities. Extensions : Add nonlinear damping ( \\(b |\\dot{\\theta}|\\) ), stochastic forcing, or multi-pendulum coupling. Visualizations Phase Portraits : Illustrate dynamic complexity. Poincar\u00e9 Sections : Highlight transitions to chaos. Bifurcation Diagrams : Plot max \\(\\theta\\) vs. \\(F\\) or \\(\\omega_d\\) (requires additional coding). Conclusion The forced damped pendulum reveals a spectrum of behaviors governed by damping, forcing amplitude, and frequency. This simulation captures its essence, from resonance to chaos, offering a window into nonlinear dynamics with broad applications.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Simulation","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"The forced damped pendulum is a classic nonlinear system that exhibits a wide range of behaviors\u2014from simple oscillations to chaos\u2014due to the interplay of damping, gravitational restoring forces, and external periodic driving. This exploration bridges fundamental physics with computational modeling, offering insights into both theoretical principles and real-world applications.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-differential-equation","text":"The motion of a forced damped pendulum is described by a second-order nonlinear differential equation: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = F \\cos(\\omega_d t) $$ Where: - \\(\\theta\\) : Angular displacement (radians). - \\(b\\) : Damping coefficient (s\u207b\u00b9). - \\(g\\) : Gravitational acceleration (m/s\u00b2). - \\(L\\) : Pendulum length (m). - \\(F\\) : Driving force amplitude (s\u207b\u00b2). - \\(\\omega_d\\) : Driving frequency (rad/s). This equation balances angular acceleration, viscous damping, gravitational restoring force, and periodic forcing.","title":"Governing Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small \\(\\theta\\) , \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to a linear forced damped oscillator: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = F \\cos(\\omega_d t) $$ Where \\(\\omega_0 = \\sqrt{g/L}\\) is the natural frequency. The general solution is: - Homogeneous : \\(\\theta_h(t) = A e^{-\\frac{b}{2}t} \\cos(\\omega t + \\phi)\\) , with \\(\\omega = \\sqrt{\\omega_0^2 - (b/2)^2}\\) (underdamped case). Particular : \\(\\theta_p(t) = A_d \\cos(\\omega_d t - \\delta)\\) , where: $$ A_d = \\frac{F}{\\sqrt{(\\omega_0^2 - \\omega_d^2)^2 + (b \\omega_d)^2}}, \\quad \\delta = \\tan^{-1}\\left(\\frac{b \\omega_d}{\\omega_0^2 - \\omega_d^2}\\right) $$ Total : \\(\\theta(t) = \\theta_h(t) + \\theta_p(t)\\) . The transient ( \\(\\theta_h\\) ) decays, leaving the steady-state oscillation.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance","text":"Resonance occurs when \\(\\omega_d \\approx \\omega_0\\) , maximizing \\(A_d\\) . For light damping ( \\(b \\ll \\omega_0\\) ), the amplitude peaks sharply, amplifying energy input from the driving force.","title":"Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameter-influence","text":"Damping ( \\(b\\) ) : Reduces amplitude and prevents unbounded growth at resonance. High \\(b\\) can suppress chaos. Driving Amplitude ( \\(F\\) ) : Small \\(F\\) yields periodic motion; large \\(F\\) can drive the system into chaos. Driving Frequency ( \\(\\omega_d\\) ) : Near \\(\\omega_0\\) , resonance amplifies motion. Far from \\(\\omega_0\\) , motion may become quasiperiodic or chaotic.","title":"Parameter Influence"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"Beyond small angles, the \\(\\sin\\theta\\) nonlinearity introduces complex dynamics: - Periodic Motion : At low \\(F\\) or \\(\\omega_d \\approx \\omega_0\\) , motion synchronizes with the drive. - Quasiperiodic Motion : Multiple incommensurate frequencies emerge as \\(F\\) increases. - Chaotic Motion : High \\(F\\) and specific \\(\\omega_d\\) lead to unpredictable, aperiodic behavior, sensitive to initial conditions.","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting : Oscillatory motion in piezoelectric devices converts mechanical energy to electricity. Suspension Bridges : External forces (wind) can induce resonant or chaotic vibrations, informing design. Circuits : Driven RLC circuits mirror this system, aiding oscillator design.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-simulation","text":"Below is a Python script using the Runge-Kutta (RK4) method to solve the nonlinear equation and visualize the dynamics: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # m/s\u00b2 L = 1.0 # m omega0 = np.sqrt(g / L) # Differential equation def pendulum(t, y, b, F, omega_d): theta, theta_dot = y return [theta_dot, -b * theta_dot - (g / L) * np.sin(theta) + F * np.cos(omega_d * t)] # Simulation function def simulate_pendulum(b, F, omega_d, t_max=50, theta0=0.1, theta_dot0=0): t_span = (0, t_max) t_eval = np.linspace(0, t_max, 1000) sol = solve_ivp(pendulum, t_span, [theta0, theta_dot0], args=(b, F, omega_d), method='RK45', t_eval=t_eval, rtol=1e-6) return sol.t, sol.y[0], sol.y[1] # Poincar\u00e9 section def poincare_section(t, theta, theta_dot, omega_d): period = 2 * np.pi / omega_d indices = np.where(np.mod(t, period) < 0.01)[0] # Sample at drive phase return theta[indices], theta_dot[indices] # Plotting plt.figure(figsize=(15, 10)) # Cases to explore cases = [ {\"b\": 0.1, \"F\": 0.5, \"omega_d\": omega0, \"label\": \"Resonance\"}, {\"b\": 0.5, \"F\": 1.2, \"omega_d\": 1.2, \"label\": \"Moderate Forcing\"}, {\"b\": 0.2, \"F\": 1.5, \"omega_d\": 1.4, \"label\": \"Chaotic\"} ] for i, case in enumerate(cases, 1): t, theta, theta_dot = simulate_pendulum(case[\"b\"], case[\"F\"], case[\"omega_d\"]) # Time series plt.subplot(3, 3, i) plt.plot(t, theta, 'b-', lw=1) plt.title(f\"{case['label']} (b={case['b']}, F={case['F']}, \u03c9d={case['omega_d']:.1f})\") plt.xlabel(\"Time (s)\") plt.ylabel(\"\u03b8 (rad)\") # Phase portrait plt.subplot(3, 3, i + 3) plt.plot(theta, theta_dot, 'r-', lw=0.5) plt.title(\"Phase Portrait\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") # Poincar\u00e9 section theta_p, theta_dot_p = poincare_section(t, theta, theta_dot, case[\"omega_d\"]) plt.subplot(3, 3, i + 6) plt.scatter(theta_p, theta_dot_p, s=5, c='k') plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") plt.tight_layout() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#output-description","text":"Time Series : Shows \\(\\theta(t)\\) for resonance (periodic), moderate forcing (quasiperiodic), and chaotic motion. Phase Portraits : Plots \\(\\theta\\) vs. \\(\\dot{\\theta}\\) , revealing closed loops (periodic), layered patterns (quasiperiodic), or dense filling (chaotic). Poincar\u00e9 Sections : Samples at the driving period, showing points clustering (periodic), forming curves (quasiperiodic), or scattering (chaotic).","title":"Output Description"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#deliverables","text":"","title":"Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#general-solutions","text":"Small Angles : Linear solution with decaying transient and steady-state oscillation. Nonlinear : Numerical solutions reveal periodic, quasiperiodic, or chaotic regimes depending on parameters.","title":"General Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#graphical-representations","text":"Resonance ( \\(b=0.1, F=0.5, \\omega_d=\\omega_0\\) ) : Large, stable oscillations. Moderate Forcing ( \\(b=0.5, F=1.2, \\omega_d=1.2\\) ) : Complex but bounded motion. Chaotic ( \\(b=0.2, F=1.5, \\omega_d=1.4\\) ) : erratic, unpredictable swings.","title":"Graphical Representations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations-and-extensions","text":"Limitations : Assumes constant \\(b\\) , periodic forcing, and no friction irregularities. Extensions : Add nonlinear damping ( \\(b |\\dot{\\theta}|\\) ), stochastic forcing, or multi-pendulum coupling.","title":"Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visualizations","text":"Phase Portraits : Illustrate dynamic complexity. Poincar\u00e9 Sections : Highlight transitions to chaos. Bifurcation Diagrams : Plot max \\(\\theta\\) vs. \\(F\\) or \\(\\omega_d\\) (requires additional coding).","title":"Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum reveals a spectrum of behaviors governed by damping, forcing amplitude, and frequency. This simulation captures its essence, from resonance to chaos, offering a window into nonlinear dynamics with broad applications.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Simulation Orbital Period and Orbital Radius: Exploring Kepler's Third Law Kepler's Third Law is a fundamental principle in celestial mechanics that links the square of a body\u2019s orbital period ( \\(T^2\\) ) to the cube of its orbital radius ( \\(r^3\\) ). This relationship provides valuable insights into gravitational interactions and forms the basis of our understanding of orbits, including satellites and exoplanets. In this section, we derive this law for circular orbits, examine its implications, analyze real-world examples, and simulate it using computational methods. 1. Theoretical Derivation Circular Orbits For a body in a circular orbit around a central mass \\(M\\) (e.g., a planet around a star), two forces balance: the gravitational force and the centripetal force required for circular motion. Gravitational Force : $$ F_g = \\frac{G M m}{r^2} $$ where \\(G\\) is the gravitational constant, \\(m\\) is the orbiting body\u2019s mass, and \\(r\\) is the orbital radius. Centripetal Force : $$ F_c = \\frac{m v^2}{r} $$ where \\(v\\) is the orbital velocity. Equating these: $$ \\frac{G M m}{r^2} = \\frac{m v^2}{r} $$ Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and simplify: $$ \\frac{G M}{r^2} = \\frac{v^2}{r} $$ $$ v^2 = \\frac{G M}{r} $$ The orbital period \\(T\\) is the time for one complete orbit, related to velocity by: $$ v = \\frac{2\\pi r}{T} $$ Square this: $$ v^2 = \\frac{4\\pi^2 r^2}{T^2} $$ Substitute into the force balance: $$ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} $$ Multiply through by \\(T^2\\) and divide by \\(r\\) : $$ 4\\pi^2 r^2 = \\frac{G M T^2}{r} $$ $$ T^2 = \\frac{4\\pi^2}{G M} r^3 $$ Thus: $$ T^2 = k r^3 $$ where \\(k = \\frac{4\\pi^2}{G M}\\) is a constant for a given central mass \\(M\\) . This is Kepler\u2019s Third Law for circular orbits. 2. Implications for Astronomy Planetary Masses : If \\(T\\) and \\(r\\) are measured for a satellite or moon, \\(M\\) of the central body can be calculated: $$ M = \\frac{4\\pi^2 r^3}{G T^2} $$ Distances : For known \\(M\\) (e.g., the Sun), measuring \\(T\\) determines \\(r\\) . System Consistency : The law holds across a planetary system, enabling comparisons (e.g., Earth vs. Mars orbits). 3. Real-World Examples Moon around Earth : \\(r \\approx 384,400\\) km = \\(3.844 \\times 10^8\\) m. \\(T \\approx 27.32\\) days = \\(2.36 \\times 10^6\\) s. \\(M_{\\text{Earth}} \\approx 5.972 \\times 10^{24}\\) kg. Check: \\(T^2 = (2.36 \\times 10^6)^2 \\approx 5.57 \\times 10^{12}\\) , \\(r^3 = (3.844 \\times 10^8)^3 \\approx 5.67 \\times 10^{25}\\) , ratio consistent with \\(k\\) . Earth around Sun : \\(r \\approx 1\\) AU = \\(1.496 \\times 10^{11}\\) m. \\(T \\approx 365.25\\) days = \\(3.156 \\times 10^7\\) s. \\(M_{\\text{Sun}} \\approx 1.989 \\times 10^{30}\\) kg. Verified similarly. 4. Implementation Python Simulation This script simulates circular orbits and plots \\(T^2\\) vs. \\(r^3\\) : import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m\u00b3 kg\u207b\u00b9 s\u207b\u00b2 M_sun = 1.989e30 # kg (Sun) M_earth = 5.972e24 # kg (Earth) # Orbital period function def orbital_period(r, M): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Data for simulation r_values = np.logspace(7, 11, 100) # 10^7 to 10^11 m T_sun = orbital_period(r_values, M_sun) / (24 * 3600) # Convert to days T_earth = orbital_period(r_values, M_earth) / (24 * 3600) # Real-world examples moon_r = 3.844e8 # m moon_T = 27.32 # days earth_r = 1.496e11 # m earth_T = 365.25 # days # Plotting plt.figure(figsize=(12, 6)) # Circular orbit visualization plt.subplot(1, 2, 1) theta = np.linspace(0, 2 * np.pi, 100) for r in [moon_r, earth_r / 100]: # Scaled for visibility x = r * np.cos(theta) y = r * np.sin(theta) plt.plot(x, y, lw=1) plt.plot(0, 0, 'yo', label=\"Central Mass\") plt.title(\"Circular Orbits (Scaled)\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.legend() plt.axis(\"equal\") # T\u00b2 vs r\u00b3 plt.subplot(1, 2, 2) plt.loglog(r_values**3, T_sun**2, 'b-', label=\"Sun (Planets)\") plt.loglog(r_values**3, T_earth**2, 'g-', label=\"Earth (Satellites)\") plt.loglog([moon_r**3], [moon_T**2], 'ro', label=\"Moon\") plt.loglog([earth_r**3], [earth_T**2], 'ko', label=\"Earth\") plt.title(\"T\u00b2 vs r\u00b3 (Kepler's Third Law)\") plt.xlabel(\"r\u00b3 (m\u00b3)\") plt.ylabel(\"T\u00b2 (days\u00b2)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() Output Description Left Plot : Scaled circular orbits (e.g., Moon, Earth-like) around a central mass. Right Plot : Log-log plot of \\(T^2\\) vs. \\(r^3\\) , showing linearity (slope 1) for Sun and Earth systems, with Moon and Earth data points overlaid. Deliverables Detailed Explanation Derivation : \\(T^2 \\propto r^3\\) arises from balancing gravitational and centripetal forces. Implications : Enables mass and distance calculations, foundational for astronomy. Graphical Representations Orbits : Visualizes circular paths. \\(T^2\\) vs. \\(r^3\\) : Confirms the law with real and simulated data. Extensions to Elliptical Orbits Kepler\u2019s Third Law generalizes to elliptical orbits using the semi-major axis \\(a\\) instead of \\(r\\) : $$ T^2 = \\frac{4\\pi^2}{G M} a^3 $$ This holds for planets, comets, and binary stars, with \\(a\\) as the average distance. The simulation could be extended by parameterizing elliptical paths. Conclusion Kepler\u2019s Third Law elegantly connects the orbital period to the radius, supported by both theory and simulation. Its applications range from lunar orbits to exoplanet discovery, with extensions to elliptical orbits expanding its scope.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Simulation","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius-exploring-keplers-third-law","text":"Kepler's Third Law is a fundamental principle in celestial mechanics that links the square of a body\u2019s orbital period ( \\(T^2\\) ) to the cube of its orbital radius ( \\(r^3\\) ). This relationship provides valuable insights into gravitational interactions and forms the basis of our understanding of orbits, including satellites and exoplanets. In this section, we derive this law for circular orbits, examine its implications, analyze real-world examples, and simulate it using computational methods.","title":"Orbital Period and Orbital Radius: Exploring Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation","text":"","title":"1. Theoretical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#circular-orbits","text":"For a body in a circular orbit around a central mass \\(M\\) (e.g., a planet around a star), two forces balance: the gravitational force and the centripetal force required for circular motion. Gravitational Force : $$ F_g = \\frac{G M m}{r^2} $$ where \\(G\\) is the gravitational constant, \\(m\\) is the orbiting body\u2019s mass, and \\(r\\) is the orbital radius. Centripetal Force : $$ F_c = \\frac{m v^2}{r} $$ where \\(v\\) is the orbital velocity. Equating these: $$ \\frac{G M m}{r^2} = \\frac{m v^2}{r} $$ Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and simplify: $$ \\frac{G M}{r^2} = \\frac{v^2}{r} $$ $$ v^2 = \\frac{G M}{r} $$ The orbital period \\(T\\) is the time for one complete orbit, related to velocity by: $$ v = \\frac{2\\pi r}{T} $$ Square this: $$ v^2 = \\frac{4\\pi^2 r^2}{T^2} $$ Substitute into the force balance: $$ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} $$ Multiply through by \\(T^2\\) and divide by \\(r\\) : $$ 4\\pi^2 r^2 = \\frac{G M T^2}{r} $$ $$ T^2 = \\frac{4\\pi^2}{G M} r^3 $$ Thus: $$ T^2 = k r^3 $$ where \\(k = \\frac{4\\pi^2}{G M}\\) is a constant for a given central mass \\(M\\) . This is Kepler\u2019s Third Law for circular orbits.","title":"Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Planetary Masses : If \\(T\\) and \\(r\\) are measured for a satellite or moon, \\(M\\) of the central body can be calculated: $$ M = \\frac{4\\pi^2 r^3}{G T^2} $$ Distances : For known \\(M\\) (e.g., the Sun), measuring \\(T\\) determines \\(r\\) . System Consistency : The law holds across a planetary system, enabling comparisons (e.g., Earth vs. Mars orbits).","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"Moon around Earth : \\(r \\approx 384,400\\) km = \\(3.844 \\times 10^8\\) m. \\(T \\approx 27.32\\) days = \\(2.36 \\times 10^6\\) s. \\(M_{\\text{Earth}} \\approx 5.972 \\times 10^{24}\\) kg. Check: \\(T^2 = (2.36 \\times 10^6)^2 \\approx 5.57 \\times 10^{12}\\) , \\(r^3 = (3.844 \\times 10^8)^3 \\approx 5.67 \\times 10^{25}\\) , ratio consistent with \\(k\\) . Earth around Sun : \\(r \\approx 1\\) AU = \\(1.496 \\times 10^{11}\\) m. \\(T \\approx 365.25\\) days = \\(3.156 \\times 10^7\\) s. \\(M_{\\text{Sun}} \\approx 1.989 \\times 10^{30}\\) kg. Verified similarly.","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation","text":"This script simulates circular orbits and plots \\(T^2\\) vs. \\(r^3\\) : import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m\u00b3 kg\u207b\u00b9 s\u207b\u00b2 M_sun = 1.989e30 # kg (Sun) M_earth = 5.972e24 # kg (Earth) # Orbital period function def orbital_period(r, M): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Data for simulation r_values = np.logspace(7, 11, 100) # 10^7 to 10^11 m T_sun = orbital_period(r_values, M_sun) / (24 * 3600) # Convert to days T_earth = orbital_period(r_values, M_earth) / (24 * 3600) # Real-world examples moon_r = 3.844e8 # m moon_T = 27.32 # days earth_r = 1.496e11 # m earth_T = 365.25 # days # Plotting plt.figure(figsize=(12, 6)) # Circular orbit visualization plt.subplot(1, 2, 1) theta = np.linspace(0, 2 * np.pi, 100) for r in [moon_r, earth_r / 100]: # Scaled for visibility x = r * np.cos(theta) y = r * np.sin(theta) plt.plot(x, y, lw=1) plt.plot(0, 0, 'yo', label=\"Central Mass\") plt.title(\"Circular Orbits (Scaled)\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.legend() plt.axis(\"equal\") # T\u00b2 vs r\u00b3 plt.subplot(1, 2, 2) plt.loglog(r_values**3, T_sun**2, 'b-', label=\"Sun (Planets)\") plt.loglog(r_values**3, T_earth**2, 'g-', label=\"Earth (Satellites)\") plt.loglog([moon_r**3], [moon_T**2], 'ro', label=\"Moon\") plt.loglog([earth_r**3], [earth_T**2], 'ko', label=\"Earth\") plt.title(\"T\u00b2 vs r\u00b3 (Kepler's Third Law)\") plt.xlabel(\"r\u00b3 (m\u00b3)\") plt.ylabel(\"T\u00b2 (days\u00b2)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#output-description","text":"Left Plot : Scaled circular orbits (e.g., Moon, Earth-like) around a central mass. Right Plot : Log-log plot of \\(T^2\\) vs. \\(r^3\\) , showing linearity (slope 1) for Sun and Earth systems, with Moon and Earth data points overlaid.","title":"Output Description"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deliverables","text":"","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_1/#detailed-explanation","text":"Derivation : \\(T^2 \\propto r^3\\) arises from balancing gravitational and centripetal forces. Implications : Enables mass and distance calculations, foundational for astronomy.","title":"Detailed Explanation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graphical-representations","text":"Orbits : Visualizes circular paths. \\(T^2\\) vs. \\(r^3\\) : Confirms the law with real and simulated data.","title":"Graphical Representations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extensions-to-elliptical-orbits","text":"Kepler\u2019s Third Law generalizes to elliptical orbits using the semi-major axis \\(a\\) instead of \\(r\\) : $$ T^2 = \\frac{4\\pi^2}{G M} a^3 $$ This holds for planets, comets, and binary stars, with \\(a\\) as the average distance. The simulation could be extended by parameterizing elliptical paths.","title":"Extensions to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law elegantly connects the orbital period to the radius, supported by both theory and simulation. Its applications range from lunar orbits to exoplanet discovery, with extensions to elliptical orbits expanding its scope.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Escape velocity and cosmic velocities are essential concepts in astrophysics and space exploration. They describe the speeds necessary to overcome gravitational forces at different scales\u2014whether it involves escaping a planet, orbiting around it, or departing from a star system. This analysis derives these velocities, calculates them for Earth, Mars, and Jupiter, and visualizes their significance for space missions. 1. Definitions and Physical Meaning Escape Velocity ( \\(v_e\\) ) : The minimum speed an object must achieve to escape a celestial body\u2019s gravitational pull without further propulsion, assuming no atmospheric drag. It\u2019s the \"second cosmic velocity\" in the context of planetary escape. First Cosmic Velocity ( \\(v_1\\) ) : The orbital velocity for a circular orbit just above a planet\u2019s surface (ignoring atmosphere). It allows a satellite to maintain a low orbit. Second Cosmic Velocity ( \\(v_2\\) ) : Identical to escape velocity, it\u2019s the speed to escape a planet\u2019s gravity entirely from its surface. Third Cosmic Velocity ( \\(v_3\\) ) : The speed required to escape a star system (e.g., the Solar System) from a planet\u2019s orbit, accounting for both planetary and stellar gravitational potentials. 2. Mathematical Derivations Escape Velocity ( \\(v_e\\) or \\(v_2\\) ) Using conservation of energy: - Initial energy: Kinetic ( \\(\\frac{1}{2}mv_e^2\\) ) + Potential ( \\(-\\frac{GMm}{R}\\) ) = 0 (at infinity, total energy is zero). - At the surface ( \\(r = R\\) ): $$ \\frac{1}{2}mv_e^2 - \\frac{GMm}{R} = 0 $$ $$ v_e = \\sqrt{\\frac{2GM}{R}} $$ Where \\(G\\) is the gravitational constant, \\(M\\) is the body\u2019s mass, and \\(R\\) is its radius. First Cosmic Velocity ( \\(v_1\\) ) For a circular orbit at \\(r = R\\) , gravitational force equals centripetal force: $$ \\frac{GMm}{R^2} = \\frac{mv_1^2}{R} $$ $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Note: \\(v_e = \\sqrt{2} v_1\\) . Third Cosmic Velocity ( \\(v_3\\) ) This is the velocity to escape the Sun\u2019s gravity from a planet\u2019s orbit (e.g., Earth\u2019s distance from the Sun, \\(d\\) ). Total energy must be zero at infinity: - Initial: \\(\\frac{1}{2}mv_3^2 - \\frac{GM_{\\text{planet}}m}{R} - \\frac{GM_{\\text{sun}}m}{d}\\) . - At infinity: 0. Assuming launch from Earth\u2019s surface and simplifying (planet\u2019s orbit velocity contributes): $$ v_3 \\approx \\sqrt{v_e^2 + v_{\\text{esc,sun}}^2} $$ Where \\(v_{\\text{esc,sun}} = \\sqrt{\\frac{2GM_{\\text{sun}}}{d}}\\) . Practically, \\(v_3\\) is adjusted for orbital mechanics (e.g., Earth\u2019s orbital speed ~29.8 km/s adds complexity). 3. Calculations and Visualization Python Script This script calculates and plots \\(v_1\\) , \\(v_2\\) ( \\(v_e\\) ), and an approximate \\(v_3\\) for Earth, Mars, and Jupiter: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m\u00b3 kg\u207b\u00b9 s\u207b\u00b2 M_sun = 1.989e30 # kg # Celestial body data bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6.371e6, \"d\": 1.496e11}, # d = distance to Sun \"Mars\": {\"M\": 6.417e23, \"R\": 3.390e6, \"d\": 2.279e11}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 6.991e7, \"d\": 7.785e11} } # Functions def v1(M, R): return np.sqrt(G * M / R) / 1000 # km/s def v2(M, R): return np.sqrt(2 * G * M / R) / 1000 # km/s def v3_approx(M_planet, R, d): ve_planet = v2(M_planet, R) * 1000 # Back to m/s ve_sun = np.sqrt(2 * G * M_sun / d) # Escape from Sun at planet's orbit return (np.sqrt(ve_planet**2 + ve_sun**2)) / 1000 # km/s # Calculate velocities data = {} for body, params in bodies.items(): data[body] = { \"v1\": v1(params[\"M\"], params[\"R\"]), \"v2\": v2(params[\"M\"], params[\"R\"]), \"v3\": v3_approx(params[\"M\"], params[\"R\"], params[\"d\"]) } # Plotting plt.figure(figsize=(10, 6)) x = np.arange(len(bodies)) width = 0.25 plt.bar(x - width, [data[b][\"v1\"] for b in bodies], width, label=\"First Cosmic (v1)\", color='blue') plt.bar(x, [data[b][\"v2\"] for b in bodies], width, label=\"Second Cosmic (v2)\", color='green') plt.bar(x + width, [data[b][\"v3\"] for b in bodies], width, label=\"Third Cosmic (v3)\", color='red') plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Earth, Mars, and Jupiter\") plt.xticks(x, bodies.keys()) plt.legend() plt.grid(True, linestyle='--', alpha=0.7) plt.show() # Print values for body, velocities in data.items(): print(f\"{body}:\") print(f\" v1 = {velocities['v1']:.2f} km/s\") print(f\" v2 = {velocities['v2']:.2f} km/s\") print(f\" v3 = {velocities['v3']:.2f} km/s\") Output Earth : \\(v_1 \\approx 7.91\\) km/s, \\(v_2 \\approx 11.19\\) km/s, \\(v_3 \\approx 42.14\\) km/s. Mars : \\(v_1 \\approx 3.55\\) km/s, \\(v_2 \\approx 5.03\\) km/s, \\(v_3 \\approx 42.47\\) km/s. Jupiter : \\(v_1 \\approx 42.14\\) km/s, \\(v_2 \\approx 59.54\\) km/s, \\(v_3 \\approx 61.99\\) km/s. Graph : Bar chart comparing \\(v_1\\) , \\(v_2\\) , and \\(v_3\\) for each body. 4. Importance in Space Exploration Satellites ( \\(v_1\\) ) : Achieving \\(v_1\\) (e.g., 7.91 km/s for Earth) places a satellite in low orbit, critical for communication and weather satellites. Planetary Escape ( \\(v_2\\) ) : Rockets must exceed \\(v_2\\) (e.g., 11.19 km/s for Earth) to reach space or other planets, as in Apollo missions. Interstellar Travel ( \\(v_3\\) ) : \\(v_3\\) (e.g., 42.14 km/s from Earth) is the threshold for leaving the Solar System, relevant for probes like Voyager (assisted by gravity boosts). Deliverables Detailed Explanation \\(v_1\\) : Orbital speed at surface radius, dependent on \\(M\\) and \\(R\\) . \\(v_2\\) : Escape speed, \\(\\sqrt{2}\\) times \\(v_1\\) , scales with mass and inversely with radius. \\(v_3\\) : Combines planetary and solar escape, dominated by Sun\u2019s gravity at large \\(d\\) . Graphical Representation Bar chart shows \\(v_1 < v_2 < v_3\\) for each body, with Jupiter\u2019s high mass driving larger values, and Mars\u2019 smaller size yielding lower ones. Conclusion Escape and cosmic velocities play a crucial role in space exploration, determining the energy needed for achieving orbits and escapes. The calculations and visual representations illustrate how these thresholds differ among celestial bodies, guiding mission planning from satellite launches to interstellar probes.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"Escape velocity and cosmic velocities are essential concepts in astrophysics and space exploration. They describe the speeds necessary to overcome gravitational forces at different scales\u2014whether it involves escaping a planet, orbiting around it, or departing from a star system. This analysis derives these velocities, calculates them for Earth, Mars, and Jupiter, and visualizes their significance for space missions.","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-and-physical-meaning","text":"Escape Velocity ( \\(v_e\\) ) : The minimum speed an object must achieve to escape a celestial body\u2019s gravitational pull without further propulsion, assuming no atmospheric drag. It\u2019s the \"second cosmic velocity\" in the context of planetary escape. First Cosmic Velocity ( \\(v_1\\) ) : The orbital velocity for a circular orbit just above a planet\u2019s surface (ignoring atmosphere). It allows a satellite to maintain a low orbit. Second Cosmic Velocity ( \\(v_2\\) ) : Identical to escape velocity, it\u2019s the speed to escape a planet\u2019s gravity entirely from its surface. Third Cosmic Velocity ( \\(v_3\\) ) : The speed required to escape a star system (e.g., the Solar System) from a planet\u2019s orbit, accounting for both planetary and stellar gravitational potentials.","title":"1. Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations","text":"","title":"2. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocity-v_e-or-v_2","text":"Using conservation of energy: - Initial energy: Kinetic ( \\(\\frac{1}{2}mv_e^2\\) ) + Potential ( \\(-\\frac{GMm}{R}\\) ) = 0 (at infinity, total energy is zero). - At the surface ( \\(r = R\\) ): $$ \\frac{1}{2}mv_e^2 - \\frac{GMm}{R} = 0 $$ $$ v_e = \\sqrt{\\frac{2GM}{R}} $$ Where \\(G\\) is the gravitational constant, \\(M\\) is the body\u2019s mass, and \\(R\\) is its radius.","title":"Escape Velocity (\\(v_e\\) or \\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"For a circular orbit at \\(r = R\\) , gravitational force equals centripetal force: $$ \\frac{GMm}{R^2} = \\frac{mv_1^2}{R} $$ $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Note: \\(v_e = \\sqrt{2} v_1\\) .","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"This is the velocity to escape the Sun\u2019s gravity from a planet\u2019s orbit (e.g., Earth\u2019s distance from the Sun, \\(d\\) ). Total energy must be zero at infinity: - Initial: \\(\\frac{1}{2}mv_3^2 - \\frac{GM_{\\text{planet}}m}{R} - \\frac{GM_{\\text{sun}}m}{d}\\) . - At infinity: 0. Assuming launch from Earth\u2019s surface and simplifying (planet\u2019s orbit velocity contributes): $$ v_3 \\approx \\sqrt{v_e^2 + v_{\\text{esc,sun}}^2} $$ Where \\(v_{\\text{esc,sun}} = \\sqrt{\\frac{2GM_{\\text{sun}}}{d}}\\) . Practically, \\(v_3\\) is adjusted for orbital mechanics (e.g., Earth\u2019s orbital speed ~29.8 km/s adds complexity).","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-calculations-and-visualization","text":"","title":"3. Calculations and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-script","text":"This script calculates and plots \\(v_1\\) , \\(v_2\\) ( \\(v_e\\) ), and an approximate \\(v_3\\) for Earth, Mars, and Jupiter: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m\u00b3 kg\u207b\u00b9 s\u207b\u00b2 M_sun = 1.989e30 # kg # Celestial body data bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6.371e6, \"d\": 1.496e11}, # d = distance to Sun \"Mars\": {\"M\": 6.417e23, \"R\": 3.390e6, \"d\": 2.279e11}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 6.991e7, \"d\": 7.785e11} } # Functions def v1(M, R): return np.sqrt(G * M / R) / 1000 # km/s def v2(M, R): return np.sqrt(2 * G * M / R) / 1000 # km/s def v3_approx(M_planet, R, d): ve_planet = v2(M_planet, R) * 1000 # Back to m/s ve_sun = np.sqrt(2 * G * M_sun / d) # Escape from Sun at planet's orbit return (np.sqrt(ve_planet**2 + ve_sun**2)) / 1000 # km/s # Calculate velocities data = {} for body, params in bodies.items(): data[body] = { \"v1\": v1(params[\"M\"], params[\"R\"]), \"v2\": v2(params[\"M\"], params[\"R\"]), \"v3\": v3_approx(params[\"M\"], params[\"R\"], params[\"d\"]) } # Plotting plt.figure(figsize=(10, 6)) x = np.arange(len(bodies)) width = 0.25 plt.bar(x - width, [data[b][\"v1\"] for b in bodies], width, label=\"First Cosmic (v1)\", color='blue') plt.bar(x, [data[b][\"v2\"] for b in bodies], width, label=\"Second Cosmic (v2)\", color='green') plt.bar(x + width, [data[b][\"v3\"] for b in bodies], width, label=\"Third Cosmic (v3)\", color='red') plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Earth, Mars, and Jupiter\") plt.xticks(x, bodies.keys()) plt.legend() plt.grid(True, linestyle='--', alpha=0.7) plt.show() # Print values for body, velocities in data.items(): print(f\"{body}:\") print(f\" v1 = {velocities['v1']:.2f} km/s\") print(f\" v2 = {velocities['v2']:.2f} km/s\") print(f\" v3 = {velocities['v3']:.2f} km/s\")","title":"Python Script"},{"location":"1%20Physics/2%20Gravity/Problem_2/#output","text":"Earth : \\(v_1 \\approx 7.91\\) km/s, \\(v_2 \\approx 11.19\\) km/s, \\(v_3 \\approx 42.14\\) km/s. Mars : \\(v_1 \\approx 3.55\\) km/s, \\(v_2 \\approx 5.03\\) km/s, \\(v_3 \\approx 42.47\\) km/s. Jupiter : \\(v_1 \\approx 42.14\\) km/s, \\(v_2 \\approx 59.54\\) km/s, \\(v_3 \\approx 61.99\\) km/s. Graph : Bar chart comparing \\(v_1\\) , \\(v_2\\) , and \\(v_3\\) for each body.","title":"Output"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-importance-in-space-exploration","text":"Satellites ( \\(v_1\\) ) : Achieving \\(v_1\\) (e.g., 7.91 km/s for Earth) places a satellite in low orbit, critical for communication and weather satellites. Planetary Escape ( \\(v_2\\) ) : Rockets must exceed \\(v_2\\) (e.g., 11.19 km/s for Earth) to reach space or other planets, as in Apollo missions. Interstellar Travel ( \\(v_3\\) ) : \\(v_3\\) (e.g., 42.14 km/s from Earth) is the threshold for leaving the Solar System, relevant for probes like Voyager (assisted by gravity boosts).","title":"4. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables","text":"","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_2/#detailed-explanation","text":"\\(v_1\\) : Orbital speed at surface radius, dependent on \\(M\\) and \\(R\\) . \\(v_2\\) : Escape speed, \\(\\sqrt{2}\\) times \\(v_1\\) , scales with mass and inversely with radius. \\(v_3\\) : Combines planetary and solar escape, dominated by Sun\u2019s gravity at large \\(d\\) .","title":"Detailed Explanation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#graphical-representation","text":"Bar chart shows \\(v_1 < v_2 < v_3\\) for each body, with Jupiter\u2019s high mass driving larger values, and Mars\u2019 smaller size yielding lower ones.","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Escape and cosmic velocities play a crucial role in space exploration, determining the energy needed for achieving orbits and escapes. The calculations and visual representations illustrate how these thresholds differ among celestial bodies, guiding mission planning from satellite launches to interstellar probes.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Simulation Motivation When a payload is released from a moving rocket near Earth, its subsequent path is influenced by its initial velocity and direction, as well as Earth's gravitational force. Analyzing these trajectories is critical for space mission operations such as satellite deployment, reentry planning, or escape trajectories. Types of Trajectories Sub-orbital: The object follows a curved path and reenters Earth due to insufficient speed. Circular Orbit: The object moves at just the right speed to remain in a stable orbit at a fixed altitude. Elliptical Orbit: The object has enough speed to stay in orbit but follows an elliptical path. Escape Trajectory: The object has enough speed (greater than 11.2 km/s) to escape Earth\u2019s gravitational pull. Governing Equations The motion of the payload is determined by Newton's Law of Universal Gravitation: $$ F=\\frac{GMm}{r^2} $$ And the corresponding acceleration: $$ a=\\frac{GM}{R^2} $$ Where: G is the gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3\u00b7kg\u207b\u00b9\u00b7s\u207b\u00b2) M is Earth's mass (5.972 \u00d7 10\u00b2\u2074 kg) r is the distance from Earth's center Numerical Simulation Using Euler's method, the simulation updates the position and velocity of the payload over small time steps. The acceleration is recalculated at each step using the current position. Key steps include: Initialize position and velocity based on altitude, speed, and angle. Calculate gravitational acceleration at each step. Update velocity and position using Newtonian mechanics. Terminate if the payload impacts Earth or exceeds simulation time. Python Code The code simulates several scenarios to illustrate different trajectory types: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6371000 # Time step and duration dt = 1 t_max = 20000 def simulate_trajectory(v0, theta_deg, h0): theta = np.radians(theta_deg) r0 = R_earth + h0 x, y = r0 * np.cos(0), r0 * np.sin(0) vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x_list, y_list = [], [] for _ in np.arange(0, t_max, dt): r = np.sqrt(x**2 + y**2) if r < R_earth: break a = -G * M_earth / r**2 ax, ay = a * x / r, a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_list.append(x) y_list.append(y) return x_list, y_list scenarios = [ (7500, 0, 300000), (7800, 45, 300000), (11200, 0, 300000), (7900, 90, 300000), ] colors = ['b', 'g', 'r', 'purple'] labels = ['Sub-orbital', 'Elliptical', 'Escape', 'Circular'] plt.figure(figsize=(10,10)) for i, (v0, theta, h0) in enumerate(scenarios): x_traj, y_traj = simulate_trajectory(v0, theta, h0) plt.plot(x_traj, y_traj, label=labels[i], color=colors[i]) plt.gca().add_patch(plt.Circle((0,0), R_earth, color='gray', alpha=0.5)) plt.axis('equal') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.grid(True) plt.show() Conclusion This analysis highlights the critical importance of initial conditions in determining the fate of a payload. Whether it reenters, orbits, or escapes Earth depends entirely on its launch velocity and angle. The numerical model provides a powerful tool to visualize and predict these paths, aiding in mission planning and orbital mechanics studies.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"Simulation","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving rocket near Earth, its subsequent path is influenced by its initial velocity and direction, as well as Earth's gravitational force. Analyzing these trajectories is critical for space mission operations such as satellite deployment, reentry planning, or escape trajectories.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"Sub-orbital: The object follows a curved path and reenters Earth due to insufficient speed. Circular Orbit: The object moves at just the right speed to remain in a stable orbit at a fixed altitude. Elliptical Orbit: The object has enough speed to stay in orbit but follows an elliptical path. Escape Trajectory: The object has enough speed (greater than 11.2 km/s) to escape Earth\u2019s gravitational pull.","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-equations","text":"The motion of the payload is determined by Newton's Law of Universal Gravitation: $$ F=\\frac{GMm}{r^2} $$ And the corresponding acceleration: $$ a=\\frac{GM}{R^2} $$ Where: G is the gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3\u00b7kg\u207b\u00b9\u00b7s\u207b\u00b2) M is Earth's mass (5.972 \u00d7 10\u00b2\u2074 kg) r is the distance from Earth's center","title":"Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation","text":"Using Euler's method, the simulation updates the position and velocity of the payload over small time steps. The acceleration is recalculated at each step using the current position. Key steps include: Initialize position and velocity based on altitude, speed, and angle. Calculate gravitational acceleration at each step. Update velocity and position using Newtonian mechanics. Terminate if the payload impacts Earth or exceeds simulation time.","title":"Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code","text":"The code simulates several scenarios to illustrate different trajectory types: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6371000 # Time step and duration dt = 1 t_max = 20000 def simulate_trajectory(v0, theta_deg, h0): theta = np.radians(theta_deg) r0 = R_earth + h0 x, y = r0 * np.cos(0), r0 * np.sin(0) vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x_list, y_list = [], [] for _ in np.arange(0, t_max, dt): r = np.sqrt(x**2 + y**2) if r < R_earth: break a = -G * M_earth / r**2 ax, ay = a * x / r, a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_list.append(x) y_list.append(y) return x_list, y_list scenarios = [ (7500, 0, 300000), (7800, 45, 300000), (11200, 0, 300000), (7900, 90, 300000), ] colors = ['b', 'g', 'r', 'purple'] labels = ['Sub-orbital', 'Elliptical', 'Escape', 'Circular'] plt.figure(figsize=(10,10)) for i, (v0, theta, h0) in enumerate(scenarios): x_traj, y_traj = simulate_trajectory(v0, theta, h0) plt.plot(x_traj, y_traj, label=labels[i], color=colors[i]) plt.gca().add_patch(plt.Circle((0,0), R_earth, color='gray', alpha=0.5)) plt.axis('equal') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.grid(True) plt.show()","title":"Python Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"This analysis highlights the critical importance of initial conditions in determining the fate of a payload. Whether it reenters, orbits, or escapes Earth depends entirely on its launch velocity and angle. The numerical model provides a powerful tool to visualize and predict these paths, aiding in mission planning and orbital mechanics studies.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Simulation Introduction This report presents an investigation into the interference patterns formed by circular water waves emitted from multiple coherent point sources positioned at the vertices of a regular polygon. The objective is to analyze and visualize the resulting wave displacement patterns on the surface due to the principle of superposition. A square configuration was selected for this analysis, and all sources were assumed to emit waves with identical amplitude, wavelength, frequency, and initial phase. The resulting displacement field was computed and visualized using a Python simulation. 1. Theoretical Background The displacement of the water surface at a given point \\((x, y)\\) and time \\(t\\) from a single circular wave source located at \\((x_i, y_i)\\) is given by: \\[ \\eta_i(x, y, t) = A \\cos(k r_i - \\omega t) \\] where: \\(A\\) is the amplitude, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, \\(\\omega = 2\\pi f\\) is the angular frequency, \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the radial distance from the source to the point, and all sources are coherent (initial phase \\(\\phi = 0\\) ). The total displacement at a point due to \\(N\\) sources is the sum of the individual displacements: \\[ \\eta(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] 2. Source Configuration A regular square was chosen as the polygonal configuration. The square is centered at the origin and has a side length of \\(2a\\) . The coordinates of the four sources are: \\(S_1 = (-a, -a)\\) \\(S_2 = (-a, a)\\) \\(S_3 = (a, a)\\) \\(S_4 = (a, -a)\\) For simulation purposes, \\(a = 1.0\\) was used. 3. Simulation Method A 2D spatial grid was created to represent the water surface. For each point on the grid, the total displacement \\(\\eta(x, y, t)\\) was calculated by summing the contributions from all four sources. A snapshot at a fixed time \\(t = 0\\) was used to generate a contour plot of the displacement field. The Python code used for the simulation is shown below: import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude \u03bb = 1.0 # Wavelength f = 1.0 # Frequency k = 2 * np.pi / \u03bb # Wavenumber \u03c9 = 2 * np.pi * f # Angular frequency a = 1.0 # Half-side of square # Time snapshot t = 0 # Grid setup x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) # Source positions sources = [(-a, -a), (-a, a), (a, a), (a, -a)] # Superposition of waves eta = np.zeros_like(X) for (x0, y0) in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) eta += A * np.cos(k * R - \u03c9 * t) # Plotting plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta, levels=100, cmap='viridis') plt.colorbar(label='Displacement \u03b7(x, y, t)') plt.title('Interference Pattern from 4 Wave Sources (Square Configuration)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show() 4. Results and Discussion The resulting interference pattern exhibits symmetrical regions of constructive and destructive interference due to the coherent interaction of the waves. Key observations include: Constructive interference occurs at points where wavefronts from the sources arrive in phase, leading to higher amplitude regions (shown as bright bands or peaks). Destructive interference arises where the waves arrive out of phase, resulting in cancellation (dark nodes or lines). The overall pattern demonstrates square symmetry , reflecting the geometry of the source arrangement. The simulation effectively illustrates the spatial periodicity and complexity of interference patterns created by multiple circular wave sources. 5. Conclusion This study successfully demonstrates the use of mathematical modeling and numerical simulation to analyze the interference of circular waves from sources arranged in a regular polygon. The square configuration produced predictable, symmetric patterns, confirming theoretical expectations based on wave superposition. The methodology can be extended to other polygonal arrangements (e.g., triangle, pentagon) or adapted to include phase shifts, damping, and boundary effects for more realistic scenarios.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"Simulation","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#introduction","text":"This report presents an investigation into the interference patterns formed by circular water waves emitted from multiple coherent point sources positioned at the vertices of a regular polygon. The objective is to analyze and visualize the resulting wave displacement patterns on the surface due to the principle of superposition. A square configuration was selected for this analysis, and all sources were assumed to emit waves with identical amplitude, wavelength, frequency, and initial phase. The resulting displacement field was computed and visualized using a Python simulation.","title":"Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-theoretical-background","text":"The displacement of the water surface at a given point \\((x, y)\\) and time \\(t\\) from a single circular wave source located at \\((x_i, y_i)\\) is given by: \\[ \\eta_i(x, y, t) = A \\cos(k r_i - \\omega t) \\] where: \\(A\\) is the amplitude, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, \\(\\omega = 2\\pi f\\) is the angular frequency, \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the radial distance from the source to the point, and all sources are coherent (initial phase \\(\\phi = 0\\) ). The total displacement at a point due to \\(N\\) sources is the sum of the individual displacements: \\[ \\eta(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\]","title":"1. Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-source-configuration","text":"A regular square was chosen as the polygonal configuration. The square is centered at the origin and has a side length of \\(2a\\) . The coordinates of the four sources are: \\(S_1 = (-a, -a)\\) \\(S_2 = (-a, a)\\) \\(S_3 = (a, a)\\) \\(S_4 = (a, -a)\\) For simulation purposes, \\(a = 1.0\\) was used.","title":"2. Source Configuration"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-simulation-method","text":"A 2D spatial grid was created to represent the water surface. For each point on the grid, the total displacement \\(\\eta(x, y, t)\\) was calculated by summing the contributions from all four sources. A snapshot at a fixed time \\(t = 0\\) was used to generate a contour plot of the displacement field. The Python code used for the simulation is shown below: import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude \u03bb = 1.0 # Wavelength f = 1.0 # Frequency k = 2 * np.pi / \u03bb # Wavenumber \u03c9 = 2 * np.pi * f # Angular frequency a = 1.0 # Half-side of square # Time snapshot t = 0 # Grid setup x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) # Source positions sources = [(-a, -a), (-a, a), (a, a), (a, -a)] # Superposition of waves eta = np.zeros_like(X) for (x0, y0) in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) eta += A * np.cos(k * R - \u03c9 * t) # Plotting plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta, levels=100, cmap='viridis') plt.colorbar(label='Displacement \u03b7(x, y, t)') plt.title('Interference Pattern from 4 Wave Sources (Square Configuration)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show()","title":"3. Simulation Method"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-results-and-discussion","text":"The resulting interference pattern exhibits symmetrical regions of constructive and destructive interference due to the coherent interaction of the waves. Key observations include: Constructive interference occurs at points where wavefronts from the sources arrive in phase, leading to higher amplitude regions (shown as bright bands or peaks). Destructive interference arises where the waves arrive out of phase, resulting in cancellation (dark nodes or lines). The overall pattern demonstrates square symmetry , reflecting the geometry of the source arrangement. The simulation effectively illustrates the spatial periodicity and complexity of interference patterns created by multiple circular wave sources.","title":"4. Results and Discussion"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-conclusion","text":"This study successfully demonstrates the use of mathematical modeling and numerical simulation to analyze the interference of circular waves from sources arranged in a regular polygon. The square configuration produced predictable, symmetric patterns, confirming theoretical expectations based on wave superposition. The methodology can be extended to other polygonal arrangements (e.g., triangle, pentagon) or adapted to include phase shifts, damping, and boundary effects for more realistic scenarios.","title":"5. Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulation Simulating the Effects of the Lorentz Force 1. Introduction and Motivation The Lorentz force is fundamental to understanding the behavior of charged particles in electromagnetic fields. It is defined as: \\[ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] where: \\(q\\) is the particle charge, \\(\\mathbf{E}\\) is the electric field, \\(\\mathbf{v}\\) is the particle velocity, \\(\\mathbf{B}\\) is the magnetic field. The Lorentz force governs key phenomena in many practical systems, such as particle accelerators, plasma confinement devices, and astrophysical processes. By simulating the trajectories of charged particles under different field configurations, we gain intuitive insight into these complex motions. 2. Applications of the Lorentz Force Systems Influenced by the Lorentz Force Particle Accelerators : Use magnetic and electric fields to steer and accelerate charged particles along precise trajectories. Mass Spectrometers : Separate ions based on mass-to-charge ratio using magnetic and electric fields. Plasma Confinement : Magnetic fields trap charged particles in devices like tokamaks for nuclear fusion. Astrophysical Phenomena : Cosmic rays and charged particles spiral in planetary magnetospheres. Role of Fields Magnetic Fields ( \\(\\mathbf{B}\\) ) : Affect particle trajectory by bending their paths, often causing circular or helical motion. Electric Fields ( \\(\\mathbf{E}\\) ) : Accelerate particles linearly, changing speed and direction. Combined Fields : Create complex motions like drifts or cyclotron orbits. 3. Simulation of Particle Motion 3.1 Equations of Motion The motion is governed by Newton's second law, \\(m \\frac{d\\mathbf{v}}{dt} = \\mathbf{F}\\) : \\[ m \\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] where \\(m\\) is the particle mass, \\(\\mathbf{r}\\) the position vector. 3.2 Numerical Integration Method We use the Runge-Kutta 4th order (RK4) method for numerical integration to solve the coupled ODEs for velocity and position. 3.3 Simulation Scenarios Uniform Magnetic Field : Particle exhibits circular or helical trajectories. Uniform Electric and Magnetic Fields : Particle experiences acceleration and gyration. Crossed Fields : Particle shows drift motion perpendicular to both fields. 4. Parameter Exploration The simulation allows varying: Magnetic field strength ( \\(B\\) ) Electric field strength ( \\(E\\) ) Initial particle velocity ( \\(\\mathbf{v}_0\\) ) Particle charge ( \\(q\\) ) Particle mass ( \\(m\\) ) These variations change trajectory radius, frequency, drift velocity, and motion type. 5. Results and Visualization 5.1 Circular Motion in Uniform Magnetic Field Particle velocity perpendicular to \\(\\mathbf{B}\\) produces circular orbits. Radius \\(r = \\frac{mv}{|q|B}\\) (Larmor radius). Frequency \\(\\omega = \\frac{|q|B}{m}\\) (cyclotron frequency). 5.2 Helical Motion with Velocity Component Parallel to \\(\\mathbf{B}\\) Combination of circular and linear motion along field lines. 5.3 Drift in Crossed Electric and Magnetic Fields Particle drifts with velocity \\(\\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2}\\) . Visualization Examples 2D and 3D plots show particle trajectories. Larmor radius and drift velocities highlighted. Effects of parameter changes demonstrated visually. 6. Discussion The simulation replicates fundamental charged particle behaviors found in devices like cyclotrons and magnetic traps. For example: In cyclotrons , particles spiral outward under combined electric and magnetic fields, matching the circular/helical patterns observed. In magnetic confinement , charged particles follow helical paths around magnetic field lines, critical for plasma stability. Understanding the Lorentz force through simulation helps design and optimize these systems. Appendix: Python Code Snippet import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def lorentz_force(t, y, q, m, E, B): r = y[:3] v = y[3:] dvdt = (q/m) * (E + np.cross(v, B)) drdt = v return np.concatenate((drdt, dvdt)) def rk4_step(f, t, y, dt, *args): k1 = f(t, y, *args) k2 = f(t + dt/2, y + dt*k1/2, *args) k3 = f(t + dt/2, y + dt*k2/2, *args) k4 = f(t + dt, y + dt*k3, *args) return y + (dt/6)*(k1 + 2*k2 + 2*k3 + k4) # Parameters q = 1.6e-19 m = 9.11e-31 E = np.array([0, 0, 0]) B = np.array([0, 0, 1e-3]) v0 = np.array([1e5, 0, 0]) r0 = np.array([0, 0, 0]) y = np.concatenate((r0, v0)) dt = 1e-9 T = 1e-6 steps = int(T/dt) trajectory = np.zeros((steps, 3)) for i in range(steps): y = rk4_step(lorentz_force, i*dt, y, dt, q, m, E, B) trajectory[i] = y[:3] fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:,0], trajectory[:,1], trajectory[:,2]) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') plt.title('Charged Particle Trajectory in Uniform Magnetic Field') plt.show()","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"Simulation","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-introduction-and-motivation","text":"The Lorentz force is fundamental to understanding the behavior of charged particles in electromagnetic fields. It is defined as: \\[ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] where: \\(q\\) is the particle charge, \\(\\mathbf{E}\\) is the electric field, \\(\\mathbf{v}\\) is the particle velocity, \\(\\mathbf{B}\\) is the magnetic field. The Lorentz force governs key phenomena in many practical systems, such as particle accelerators, plasma confinement devices, and astrophysical processes. By simulating the trajectories of charged particles under different field configurations, we gain intuitive insight into these complex motions.","title":"1. Introduction and Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-applications-of-the-lorentz-force","text":"","title":"2. Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#systems-influenced-by-the-lorentz-force","text":"Particle Accelerators : Use magnetic and electric fields to steer and accelerate charged particles along precise trajectories. Mass Spectrometers : Separate ions based on mass-to-charge ratio using magnetic and electric fields. Plasma Confinement : Magnetic fields trap charged particles in devices like tokamaks for nuclear fusion. Astrophysical Phenomena : Cosmic rays and charged particles spiral in planetary magnetospheres.","title":"Systems Influenced by the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#role-of-fields","text":"Magnetic Fields ( \\(\\mathbf{B}\\) ) : Affect particle trajectory by bending their paths, often causing circular or helical motion. Electric Fields ( \\(\\mathbf{E}\\) ) : Accelerate particles linearly, changing speed and direction. Combined Fields : Create complex motions like drifts or cyclotron orbits.","title":"Role of Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-simulation-of-particle-motion","text":"","title":"3. Simulation of Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#31-equations-of-motion","text":"The motion is governed by Newton's second law, \\(m \\frac{d\\mathbf{v}}{dt} = \\mathbf{F}\\) : \\[ m \\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] where \\(m\\) is the particle mass, \\(\\mathbf{r}\\) the position vector.","title":"3.1 Equations of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#32-numerical-integration-method","text":"We use the Runge-Kutta 4th order (RK4) method for numerical integration to solve the coupled ODEs for velocity and position.","title":"3.2 Numerical Integration Method"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#33-simulation-scenarios","text":"Uniform Magnetic Field : Particle exhibits circular or helical trajectories. Uniform Electric and Magnetic Fields : Particle experiences acceleration and gyration. Crossed Fields : Particle shows drift motion perpendicular to both fields.","title":"3.3 Simulation Scenarios"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-parameter-exploration","text":"The simulation allows varying: Magnetic field strength ( \\(B\\) ) Electric field strength ( \\(E\\) ) Initial particle velocity ( \\(\\mathbf{v}_0\\) ) Particle charge ( \\(q\\) ) Particle mass ( \\(m\\) ) These variations change trajectory radius, frequency, drift velocity, and motion type.","title":"4. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-results-and-visualization","text":"","title":"5. Results and Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#51-circular-motion-in-uniform-magnetic-field","text":"Particle velocity perpendicular to \\(\\mathbf{B}\\) produces circular orbits. Radius \\(r = \\frac{mv}{|q|B}\\) (Larmor radius). Frequency \\(\\omega = \\frac{|q|B}{m}\\) (cyclotron frequency).","title":"5.1 Circular Motion in Uniform Magnetic Field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#52-helical-motion-with-velocity-component-parallel-to-mathbfb","text":"Combination of circular and linear motion along field lines.","title":"5.2 Helical Motion with Velocity Component Parallel to \\(\\mathbf{B}\\)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#53-drift-in-crossed-electric-and-magnetic-fields","text":"Particle drifts with velocity \\(\\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2}\\) .","title":"5.3 Drift in Crossed Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#visualization-examples","text":"2D and 3D plots show particle trajectories. Larmor radius and drift velocities highlighted. Effects of parameter changes demonstrated visually.","title":"Visualization Examples"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-discussion","text":"The simulation replicates fundamental charged particle behaviors found in devices like cyclotrons and magnetic traps. For example: In cyclotrons , particles spiral outward under combined electric and magnetic fields, matching the circular/helical patterns observed. In magnetic confinement , charged particles follow helical paths around magnetic field lines, critical for plasma stability. Understanding the Lorentz force through simulation helps design and optimize these systems.","title":"6. Discussion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#appendix-python-code-snippet","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def lorentz_force(t, y, q, m, E, B): r = y[:3] v = y[3:] dvdt = (q/m) * (E + np.cross(v, B)) drdt = v return np.concatenate((drdt, dvdt)) def rk4_step(f, t, y, dt, *args): k1 = f(t, y, *args) k2 = f(t + dt/2, y + dt*k1/2, *args) k3 = f(t + dt/2, y + dt*k2/2, *args) k4 = f(t + dt, y + dt*k3, *args) return y + (dt/6)*(k1 + 2*k2 + 2*k3 + k4) # Parameters q = 1.6e-19 m = 9.11e-31 E = np.array([0, 0, 0]) B = np.array([0, 0, 1e-3]) v0 = np.array([1e5, 0, 0]) r0 = np.array([0, 0, 0]) y = np.concatenate((r0, v0)) dt = 1e-9 T = 1e-6 steps = int(T/dt) trajectory = np.zeros((steps, 3)) for i in range(steps): y = rk4_step(lorentz_force, i*dt, y, dt, q, m, E, B) trajectory[i] = y[:3] fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:,0], trajectory[:,1], trajectory[:,2]) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') plt.title('Charged Particle Trajectory in Uniform Magnetic Field') plt.show()","title":"Appendix: Python Code Snippet"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Simulation Algorithm for Equivalent Resistance Using Graph Theory The algorithm models an electrical circuit as an undirected weighted graph: - Nodes : Represent junctions or terminals in the circuit. - Edges : Represent resistors, with weights equal to resistance values (in ohms, \u03a9). - Goal : Compute the equivalent resistance \\(R_{eq}\\) between two specified nodes (source \\(S\\) and sink \\(T\\) ) by iteratively simplifying the graph through series and parallel reductions until a single edge connects \\(S\\) and \\(T\\) . Key Formulas Series Reduction : For resistors \\(R_1, R_2, \\ldots, R_n\\) connected in series (forming a chain through nodes of degree 2): $$ R_{eq} = R_1 + R_2 + \\cdots + R_n $$ Example: Two resistors \\(R_1\\) and \\(R_2\\) in series yield \\(R_{eq} = R_1 + R_2\\) . Parallel Reduction : For resistors \\(R_1, R_2, \\ldots, R_n\\) connected in parallel (multiple edges between the same two nodes): $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} $$ For two resistors: $$ R_{eq} = \\frac{R_1 \\cdot R_2}{R_1 + R_2} $$ Example: Two resistors \\(R_1 = 4\u03a9\\) and \\(R_2 = 6\u03a9\\) in parallel yield: $$ R_{eq} = \\frac{4 \\cdot 6}{4 + 6} = \\frac{24}{10} = 2.4\u03a9 $$ Pseudocode The algorithm iteratively applies series and parallel reductions until the graph is reduced to a single edge between \\(S\\) and \\(T\\) . Function ComputeEquivalentResistance(G, S, T): // Input: Graph G (nodes, edges with resistance weights), source node S, sink node T // Output: Equivalent resistance R_eq between S and T While G has more than two nodes or more than one edge between S and T: // Step 1: Series Reduction For each node N in G (excluding S and T): If degree(N) == 2: Let A, B be neighbors of N Let R1 = resistance of edge (A, N) Let R2 = resistance of edge (N, B) R_eq = R1 + R2 // Series formula Remove node N and edges (A, N), (N, B) Add edge (A, B) with resistance R_eq // Step 2: Parallel Reduction For each pair of nodes (U, V) in G: If multiple edges exist between U and V: Let R1, R2, ..., Rk be resistances of parallel edges R_eq = 1 / (1/R1 + 1/R2 + ... + 1/Rk) // Parallel formula Remove all edges between U and V Add edge (U, V) with resistance R_eq // Step 3: Check for Progress If no reductions were made: Break // Non-series-parallel graphs may require advanced methods // Final Step If only one edge exists between S and T: Return resistance of edge (S, T) Else: Return error (graph not reducible) End Function How It Handles Nested Combinations Iterative Simplification : The algorithm alternates between series and parallel reductions, processing nested configurations (e.g., a parallel branch containing series resistors) by reducing substructures step-by-step. Graph Traversal : Uses depth-first search (DFS) or breadth-first search (BFS) to identify nodes with degree 2 (series) or multiple edges between node pairs (parallel). Order Independence : For series-parallel graphs, the final \\(R_{eq}\\) is independent of the reduction order, ensuring correct handling of nested structures. Limitations : Assumes series-parallel graphs. Non-series-parallel graphs (e.g., Wheatstone bridge) require extensions like delta-star transformations. Example Applications Below are three example circuits to demonstrate the algorithm\u2019s application, including the graph representation, reduction steps, and final \\(R_{eq}\\) . Example 1: Simple Series and Parallel Combination Circuit : Two resistors in series ( \\(R_1 = 2\u03a9\\) , \\(R_2 = 3\u03a9\\) ) connected in parallel with a third resistor ( \\(R_3 = 5\u03a9\\) ) between nodes \\(S\\) and \\(T\\) . Graph : - Nodes: \\(S, A, T\\) - Edges: \\((S, A, 2\u03a9), (A, T, 3\u03a9), (S, T, 5\u03a9)\\) Reduction Steps : 1. Series Reduction : - Node \\(A\\) has degree 2, with edges \\((S, A, 2\u03a9)\\) and \\((A, T, 3\u03a9)\\) . - Apply series formula: $R_{eq} = 2 + 3 = 5\u03a9$. Remove node \\(A\\) and edges; add edge \\((S, T, 5\u03a9)\\) . Updated graph: \\((S, T, 5\u03a9), (S, T, 5\u03a9)\\) . Parallel Reduction : Two edges between \\(S\\) and \\(T\\) with \\(5\u03a9\\) each. Apply parallel formula: \\(R_{eq} = \\frac{5 \\cdot 5}{5 + 5} = \\frac{25}{10} = 2.5\u03a9\\) . - Replace with edge \\((S, T, 2.5\u03a9)\\) . Result : \\(R_{eq} = 2.5\u03a9\\) Example 2: Nested Configuration Circuit : Two resistors in parallel ( \\(R_1 = 4\u03a9\\) , \\(R_2 = 6\u03a9\\) ) in series with a third resistor ( \\(R_3 = 2\u03a9\\) ) between \\(S\\) and \\(T\\) . Graph : - Nodes: \\(S, A, T\\) - Edges: \\((S, A, 4\u03a9), (S, A, 6\u03a9), (A, T, 2\u03a9)\\) Reduction Steps : 1. Parallel Reduction : - Edges \\((S, A, 4\u03a9)\\) and \\((S, A, 6\u03a9)\\) are parallel. - Apply parallel formula: $R_{eq} = \\frac{4 \\cdot 6}{4 + 6} = \\frac{24}{10} = 2.4\u03a9$. Replace with edge \\((S, A, 2.4\u03a9)\\) . Updated graph: \\((S, A, 2.4\u03a9), (A, T, 2\u03a9)\\) . Series Reduction : Node \\(A\\) has degree 2, with edges \\((S, A, 2.4\u03a9)\\) and \\((A, T, 2\u03a9)\\) . Apply series formula: \\(R_{eq} = 2.4 + 2 = 4.4\u03a9\\) . - Replace with edge \\((S, T, 4.4\u03a9)\\) . Result : \\(R_{eq} = 4.4\u03a9\\) Example 3: Complex Graph with Multiple Cycles Circuit : A square circuit with resistors on each edge ( \\(R_1 = 1\u03a9\\) , \\(R_2 = 2\u03a9\\) , \\(R_3 = 3\u03a9\\) , \\(R_4 = 4\u03a9\\) ) and a diagonal resistor ( \\(R_5 = 5\u03a9\\) ) between opposite corners \\(S\\) and \\(T\\) . Graph : - Nodes: \\(S, A, B, T\\) - Edges: \\((S, A, 1\u03a9), (A, T, 2\u03a9), (S, B, 3\u03a9), (B, T, 4\u03a9), (S, T, 5\u03a9)\\) Reduction Steps : 1. Series Reduction (Path S-A-T) : - Edges \\((S, A, 1\u03a9)\\) and \\((A, T, 2\u03a9)\\) form a series path through \\(A\\) . - Apply series formula: $R_{eq} = 1 + 2 = 3\u03a9$. Replace with edge \\((S, T, 3\u03a9)\\) . Updated graph: \\((S, T, 3\u03a9), (S, B, 3\u03a9), (B, T, 4\u03a9), (S, T, 5\u03a9)\\) . Series Reduction (Path S-B-T) : Edges \\((S, B, 3\u03a9)\\) and \\((B, T, 4\u03a9)\\) form a series path through \\(B\\) . Apply series formula: \\(R_{eq} = 3 + 4 = 7\u03a9\\) . - Replace with edge \\((S, T, 7\u03a9)\\) . - Updated graph: \\((S, T, 3\u03a9), (S, T, 7\u03a9), (S, T, 5\u03a9)\\) . 3. Parallel Reduction : - Three edges between \\(S\\) and \\(T\\) : \\(3\u03a9, 7\u03a9, 5\u03a9\\) . - Apply parallel formula: $$ \\frac{1}{R_{eq}} = \\frac{1}{3} + \\frac{1}{7} + \\frac{1}{5} = \\frac{35 + 15 + 21}{105} = \\frac{71}{105} $$ $$ R_{eq} = \\frac{105}{71} \\approx 1.48\u03a9 $$ - Replace with edge \\((S, T, \\approx 1.48\u03a9)\\) . Result : \\(R_{eq} \\approx 1.48\u03a9\\) Efficiency Analysis Time Complexity : Series Reduction : Checking nodes for degree 2 is \\(O(V)\\) per iteration. Each reduction removes a node, so at most \\(V\\) iterations. Parallel Reduction : Checking for multiple edges is \\(O(E)\\) per iteration. Edge updates are constant with adjacency lists. Total : \\(O(V + E)\\) per iteration, with up to \\(V\\) iterations, yielding \\(O(V \\cdot (V + E))\\) . For sparse graphs ( \\(E \\approx V\\) ), this is \\(O(V^2)\\) . Space Complexity : \\(O(V + E)\\) for the graph (adjacency list) plus \\(O(V)\\) for traversal stack/queue. Practical Notes : Efficient for small to medium circuits. Large graphs with many iterations may benefit from optimizations. Potential Improvements Optimized Detection : Use a priority queue to prioritize low-degree nodes or parallel edges, reducing traversal overhead. Advanced Transformations : Add delta-star transformations for non-series-parallel graphs: Delta to star conversion for a triangle with resistances \\(R_a, R_b, R_c\\) : $$ R_1 = \\frac{R_b \\cdot R_c}{R_a + R_b + R_c}, \\quad R_2 = \\frac{R_a \\cdot R_c}{R_a + R_b + R_c}, \\quad R_3 = \\frac{R_a \\cdot R_b}{R_a + R_b + R_c} $$ Graph Libraries : Use NetworkX (Python) for efficient graph operations. Matrix Methods : For complex graphs, use the Laplacian matrix to compute \\(R_{eq}\\) numerically, though this is less intuitive. Conclusion The algorithm systematically computes equivalent resistance by reducing a circuit graph using series ( \\(R_{eq} = R_1 + R_2\\) ) and parallel ( \\(\\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2}\\) ) formulas. It handles nested configurations through iterative reductions, as shown in the three examples. While efficient for series-parallel graphs, extensions like delta-star transformations or matrix methods can address more complex cases. The approach demonstrates the power of graph theory in simplifying circuit analysis.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"Simulation","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-for-equivalent-resistance-using-graph-theory","text":"The algorithm models an electrical circuit as an undirected weighted graph: - Nodes : Represent junctions or terminals in the circuit. - Edges : Represent resistors, with weights equal to resistance values (in ohms, \u03a9). - Goal : Compute the equivalent resistance \\(R_{eq}\\) between two specified nodes (source \\(S\\) and sink \\(T\\) ) by iteratively simplifying the graph through series and parallel reductions until a single edge connects \\(S\\) and \\(T\\) .","title":"Algorithm for Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-formulas","text":"Series Reduction : For resistors \\(R_1, R_2, \\ldots, R_n\\) connected in series (forming a chain through nodes of degree 2): $$ R_{eq} = R_1 + R_2 + \\cdots + R_n $$ Example: Two resistors \\(R_1\\) and \\(R_2\\) in series yield \\(R_{eq} = R_1 + R_2\\) . Parallel Reduction : For resistors \\(R_1, R_2, \\ldots, R_n\\) connected in parallel (multiple edges between the same two nodes): $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} $$ For two resistors: $$ R_{eq} = \\frac{R_1 \\cdot R_2}{R_1 + R_2} $$ Example: Two resistors \\(R_1 = 4\u03a9\\) and \\(R_2 = 6\u03a9\\) in parallel yield: $$ R_{eq} = \\frac{4 \\cdot 6}{4 + 6} = \\frac{24}{10} = 2.4\u03a9 $$","title":"Key Formulas"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"The algorithm iteratively applies series and parallel reductions until the graph is reduced to a single edge between \\(S\\) and \\(T\\) . Function ComputeEquivalentResistance(G, S, T): // Input: Graph G (nodes, edges with resistance weights), source node S, sink node T // Output: Equivalent resistance R_eq between S and T While G has more than two nodes or more than one edge between S and T: // Step 1: Series Reduction For each node N in G (excluding S and T): If degree(N) == 2: Let A, B be neighbors of N Let R1 = resistance of edge (A, N) Let R2 = resistance of edge (N, B) R_eq = R1 + R2 // Series formula Remove node N and edges (A, N), (N, B) Add edge (A, B) with resistance R_eq // Step 2: Parallel Reduction For each pair of nodes (U, V) in G: If multiple edges exist between U and V: Let R1, R2, ..., Rk be resistances of parallel edges R_eq = 1 / (1/R1 + 1/R2 + ... + 1/Rk) // Parallel formula Remove all edges between U and V Add edge (U, V) with resistance R_eq // Step 3: Check for Progress If no reductions were made: Break // Non-series-parallel graphs may require advanced methods // Final Step If only one edge exists between S and T: Return resistance of edge (S, T) Else: Return error (graph not reducible) End Function","title":"Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#how-it-handles-nested-combinations","text":"Iterative Simplification : The algorithm alternates between series and parallel reductions, processing nested configurations (e.g., a parallel branch containing series resistors) by reducing substructures step-by-step. Graph Traversal : Uses depth-first search (DFS) or breadth-first search (BFS) to identify nodes with degree 2 (series) or multiple edges between node pairs (parallel). Order Independence : For series-parallel graphs, the final \\(R_{eq}\\) is independent of the reduction order, ensuring correct handling of nested structures. Limitations : Assumes series-parallel graphs. Non-series-parallel graphs (e.g., Wheatstone bridge) require extensions like delta-star transformations.","title":"How It Handles Nested Combinations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-applications","text":"Below are three example circuits to demonstrate the algorithm\u2019s application, including the graph representation, reduction steps, and final \\(R_{eq}\\) .","title":"Example Applications"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-simple-series-and-parallel-combination","text":"Circuit : Two resistors in series ( \\(R_1 = 2\u03a9\\) , \\(R_2 = 3\u03a9\\) ) connected in parallel with a third resistor ( \\(R_3 = 5\u03a9\\) ) between nodes \\(S\\) and \\(T\\) . Graph : - Nodes: \\(S, A, T\\) - Edges: \\((S, A, 2\u03a9), (A, T, 3\u03a9), (S, T, 5\u03a9)\\) Reduction Steps : 1. Series Reduction : - Node \\(A\\) has degree 2, with edges \\((S, A, 2\u03a9)\\) and \\((A, T, 3\u03a9)\\) . - Apply series formula: $R_{eq} = 2 + 3 = 5\u03a9$. Remove node \\(A\\) and edges; add edge \\((S, T, 5\u03a9)\\) . Updated graph: \\((S, T, 5\u03a9), (S, T, 5\u03a9)\\) . Parallel Reduction : Two edges between \\(S\\) and \\(T\\) with \\(5\u03a9\\) each. Apply parallel formula: \\(R_{eq} = \\frac{5 \\cdot 5}{5 + 5} = \\frac{25}{10} = 2.5\u03a9\\) . - Replace with edge \\((S, T, 2.5\u03a9)\\) . Result : \\(R_{eq} = 2.5\u03a9\\)","title":"Example 1: Simple Series and Parallel Combination"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-nested-configuration","text":"Circuit : Two resistors in parallel ( \\(R_1 = 4\u03a9\\) , \\(R_2 = 6\u03a9\\) ) in series with a third resistor ( \\(R_3 = 2\u03a9\\) ) between \\(S\\) and \\(T\\) . Graph : - Nodes: \\(S, A, T\\) - Edges: \\((S, A, 4\u03a9), (S, A, 6\u03a9), (A, T, 2\u03a9)\\) Reduction Steps : 1. Parallel Reduction : - Edges \\((S, A, 4\u03a9)\\) and \\((S, A, 6\u03a9)\\) are parallel. - Apply parallel formula: $R_{eq} = \\frac{4 \\cdot 6}{4 + 6} = \\frac{24}{10} = 2.4\u03a9$. Replace with edge \\((S, A, 2.4\u03a9)\\) . Updated graph: \\((S, A, 2.4\u03a9), (A, T, 2\u03a9)\\) . Series Reduction : Node \\(A\\) has degree 2, with edges \\((S, A, 2.4\u03a9)\\) and \\((A, T, 2\u03a9)\\) . Apply series formula: \\(R_{eq} = 2.4 + 2 = 4.4\u03a9\\) . - Replace with edge \\((S, T, 4.4\u03a9)\\) . Result : \\(R_{eq} = 4.4\u03a9\\)","title":"Example 2: Nested Configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-complex-graph-with-multiple-cycles","text":"Circuit : A square circuit with resistors on each edge ( \\(R_1 = 1\u03a9\\) , \\(R_2 = 2\u03a9\\) , \\(R_3 = 3\u03a9\\) , \\(R_4 = 4\u03a9\\) ) and a diagonal resistor ( \\(R_5 = 5\u03a9\\) ) between opposite corners \\(S\\) and \\(T\\) . Graph : - Nodes: \\(S, A, B, T\\) - Edges: \\((S, A, 1\u03a9), (A, T, 2\u03a9), (S, B, 3\u03a9), (B, T, 4\u03a9), (S, T, 5\u03a9)\\) Reduction Steps : 1. Series Reduction (Path S-A-T) : - Edges \\((S, A, 1\u03a9)\\) and \\((A, T, 2\u03a9)\\) form a series path through \\(A\\) . - Apply series formula: $R_{eq} = 1 + 2 = 3\u03a9$. Replace with edge \\((S, T, 3\u03a9)\\) . Updated graph: \\((S, T, 3\u03a9), (S, B, 3\u03a9), (B, T, 4\u03a9), (S, T, 5\u03a9)\\) . Series Reduction (Path S-B-T) : Edges \\((S, B, 3\u03a9)\\) and \\((B, T, 4\u03a9)\\) form a series path through \\(B\\) . Apply series formula: \\(R_{eq} = 3 + 4 = 7\u03a9\\) . - Replace with edge \\((S, T, 7\u03a9)\\) . - Updated graph: \\((S, T, 3\u03a9), (S, T, 7\u03a9), (S, T, 5\u03a9)\\) . 3. Parallel Reduction : - Three edges between \\(S\\) and \\(T\\) : \\(3\u03a9, 7\u03a9, 5\u03a9\\) . - Apply parallel formula: $$ \\frac{1}{R_{eq}} = \\frac{1}{3} + \\frac{1}{7} + \\frac{1}{5} = \\frac{35 + 15 + 21}{105} = \\frac{71}{105} $$ $$ R_{eq} = \\frac{105}{71} \\approx 1.48\u03a9 $$ - Replace with edge \\((S, T, \\approx 1.48\u03a9)\\) . Result : \\(R_{eq} \\approx 1.48\u03a9\\)","title":"Example 3: Complex Graph with Multiple Cycles"},{"location":"1%20Physics/5%20Circuits/Problem_1/#efficiency-analysis","text":"Time Complexity : Series Reduction : Checking nodes for degree 2 is \\(O(V)\\) per iteration. Each reduction removes a node, so at most \\(V\\) iterations. Parallel Reduction : Checking for multiple edges is \\(O(E)\\) per iteration. Edge updates are constant with adjacency lists. Total : \\(O(V + E)\\) per iteration, with up to \\(V\\) iterations, yielding \\(O(V \\cdot (V + E))\\) . For sparse graphs ( \\(E \\approx V\\) ), this is \\(O(V^2)\\) . Space Complexity : \\(O(V + E)\\) for the graph (adjacency list) plus \\(O(V)\\) for traversal stack/queue. Practical Notes : Efficient for small to medium circuits. Large graphs with many iterations may benefit from optimizations.","title":"Efficiency Analysis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#potential-improvements","text":"Optimized Detection : Use a priority queue to prioritize low-degree nodes or parallel edges, reducing traversal overhead. Advanced Transformations : Add delta-star transformations for non-series-parallel graphs: Delta to star conversion for a triangle with resistances \\(R_a, R_b, R_c\\) : $$ R_1 = \\frac{R_b \\cdot R_c}{R_a + R_b + R_c}, \\quad R_2 = \\frac{R_a \\cdot R_c}{R_a + R_b + R_c}, \\quad R_3 = \\frac{R_a \\cdot R_b}{R_a + R_b + R_c} $$ Graph Libraries : Use NetworkX (Python) for efficient graph operations. Matrix Methods : For complex graphs, use the Laplacian matrix to compute \\(R_{eq}\\) numerically, though this is less intuitive.","title":"Potential Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"The algorithm systematically computes equivalent resistance by reducing a circuit graph using series ( \\(R_{eq} = R_1 + R_2\\) ) and parallel ( \\(\\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2}\\) ) formulas. It handles nested configurations through iterative reductions, as shown in the three examples. While efficient for series-parallel graphs, extensions like delta-star transformations or matrix methods can address more complex cases. The approach demonstrates the power of graph theory in simplifying circuit analysis.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Simulation Markdown Document: Exploring the Central Limit Theorem through Simulations Objective The Central Limit Theorem (CLT) states that the distribution of the sample mean \\(\\bar{X}\\) of a random sample of size \\(n\\) from a population with mean \\(\\mu\\) and variance \\(\\sigma^2\\) approaches a normal distribution as \\(n\\) increases, regardless of the population\u2019s distribution. This project aims to: 1. Simulate sampling distributions for different population distributions. 2. Visualize the convergence of sample means to a normal distribution. 3. Explore the influence of population shape and variance on convergence. 4. Discuss real-world applications of the CLT. Methodology Population Distributions : Uniform : Continuous on \\([0, 10]\\) . Exponential : Right-skewed with rate parameter \\(\\lambda = 1\\) . Binomial : Discrete with \\(n=10\\) , \\(p=0.5\\) . Generate a population of size \\(N = 100,000\\) for each. Sampling and Visualization : Draw random samples of sizes \\(n = 5, 10, 30, 50\\) . Compute sample means for \\(M = 10,000\\) samples. Plot histograms of sample means with a kernel density estimate (KDE) and overlay the theoretical normal distribution. Parameter Exploration : Analyze how population skewness and variance affect convergence. Verify the sampling distribution\u2019s variance. Practical Applications : Estimating population parameters. Quality control in manufacturing. Financial modeling. Key Formulas Population Parameters For each distribution, the mean \\(\\mu\\) and variance \\(\\sigma^2\\) are: - Uniform ( \\(a = 0\\) , \\(b = 10\\) ): $$ \\mu = \\frac{a + b}{2} = \\frac{0 + 10}{2} = 5 $$ $$ \\sigma^2 = \\frac{(b - a)^2}{12} = \\frac{(10 - 0)^2}{12} = \\frac{100}{12} \\approx 8.333 $$ - Exponential ( \\(\\lambda = 1\\) ): $$ \\mu = \\frac{1}{\\lambda} = \\frac{1}{1} = 1 $$ $$ \\sigma^2 = \\frac{1}{\\lambda^2} = \\frac{1}{1^2} = 1 $$ - Binomial ( \\(n = 10\\) , \\(p = 0.5\\) ): $$ \\mu = n \\cdot p = 10 \\cdot 0.5 = 5 $$ $$ \\sigma^2 = n \\cdot p \\cdot (1 - p) = 10 \\cdot 0.5 \\cdot 0.5 = 2.5 $$ Sample Mean For a sample of size \\(n\\) , the sample mean is: $$ \\bar{X} = \\frac{1}{n} \\sum_{i=1}^n X_i $$ Central Limit Theorem For a population with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , the CLT states that for large \\(n\\) , the sampling distribution of \\(\\bar{X}\\) is approximately: $$ \\bar{X} \\sim \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) $$ - Mean of the sampling distribution : $$ \\mathbb{E}(\\bar{X}) = \\mu $$ - Variance of the sampling distribution : $$ \\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n} $$ - Normal density function (for plotting): $$ f(x) = \\frac{1}{\\sqrt{2\\pi \\cdot \\frac{\\sigma^2}{n}}} \\exp\\left(-\\frac{(x - \\mu)^2}{2 \\cdot \\frac{\\sigma^2}{n}}\\right) $$ Python Implementation The following Python script simulates the sampling distributions, visualizes them with histograms, and compares empirical and theoretical variances. import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set random seed for reproducibility np.random.seed(42) # Parameters population_size = 100_000 # Population size (N) sample_sizes = [5, 10, 30, 50] # Sample sizes (n) num_samples = 10_000 # Number of samples (M) # Define populations with theoretical parameters populations = { 'Uniform': { 'data': np.random.uniform(0, 10, population_size), 'mean': 5, # (0 + 10) / 2 'variance': 100 / 12 # (10 - 0)^2 / 12 }, 'Exponential': { 'data': np.random.exponential(scale=1, size=population_size), 'mean': 1, # 1 / lambda, lambda = 1 'variance': 1 # 1 / lambda^2 }, 'Binomial': { 'data': np.random.binomial(n=10, p=0.5, size=population_size), 'mean': 5, # n * p = 10 * 0.5 'variance': 2.5 # n * p * (1 - p) } } # Function to simulate sampling and compute means def simulate_sampling(population, sample_size, num_samples): \"\"\"Generate sampling distribution of the mean.\"\"\" sample_means = [np.mean(np.random.choice(population, size=sample_size)) for _ in range(num_samples)] return np.array(sample_means) # Function to plot sampling distribution def plot_sampling_distribution(sample_means, mu, sigma, sample_size, dist_name): \"\"\"Plot histogram of sample means with theoretical normal curve.\"\"\" plt.figure(figsize=(5, 4)) sns.histplot(sample_means, bins=50, kde=True, stat='density', label='Sample Means') # Theoretical normal curve x = np.linspace(mu - 4*sigma, mu + 4*sigma, 100) plt.plot(x, 1/(sigma * np.sqrt(2*np.pi)) * np.exp(-(x-mu)**2/(2*sigma**2)), 'r--', label=f'Normal(\u03bc={mu}, \u03c3\u00b2={sigma**2:.3f})') plt.title(f'{dist_name}, n={sample_size}') plt.xlabel('Sample Mean') plt.ylabel('Density') plt.legend() plt.tight_layout() # Simulate, visualize, and analyze variances for dist_name, dist_info in populations.items(): population = dist_info['data'] mu = dist_info['mean'] pop_variance = dist_info['variance'] # Plot sampling distributions plt.figure(figsize=(15, 4)) for i, sample_size in enumerate(sample_sizes, 1): sample_means = simulate_sampling(population, sample_size, num_samples) sigma = np.sqrt(pop_variance / sample_size) plt.subplot(1, len(sample_sizes), i) plot_sampling_distribution(sample_means, mu, sigma, sample_size, dist_name) plt.suptitle(f'Sampling Distributions for {dist_name} Population') plt.show() # Variance comparison print(f\"\\n{dist_name} Distribution (\u03bc={mu}, \u03c3\u00b2={pop_variance:.3f}):\") for sample_size in sample_sizes: sample_means = simulate_sampling(population, sample_size, num_samples) empirical_variance = np.var(sample_means, ddof=1) theoretical_variance = pop_variance / sample_size print(f\"Sample Size {sample_size}: Empirical Var = {empirical_variance:.4f}, \" f\"Theoretical Var = {theoretical_variance:.4f}\") Expected Results Visualizations : For each distribution (Uniform, Exponential, Binomial), four histograms (for \\(n = 5, 10, 30, 50\\) ) display the sampling distribution of \\(\\bar{X}\\) . A red dashed line shows the theoretical normal distribution \\(\\mathcal{N}(\\mu, \\sigma^2/n)\\) . Uniform : Rapid convergence to normality by \\(n=10\\) due to symmetry. Exponential : Skewed at \\(n=5\\) , approximates normality by \\(n=30\\) . Binomial : Near-normal by \\(n=30\\) , reflecting moderate symmetry. Variance Analysis : Empirical variances of sample means closely match the theoretical \\(\\frac{\\sigma^2}{n}\\) . Example (Uniform, \\(\\sigma^2 = 8.333\\) ): $$ n=5: \\text{Var}(\\bar{X}) = \\frac{8.333}{5} \\approx 1.667 $$ $$ n=50: \\text{Var}(\\bar{X}) = \\frac{8.333}{50} \\approx 0.167 $$ Parameter Exploration Shape Influence : Uniform : Symmetrical, no skewness, converges quickly (by \\(n=10\\) ). Exponential : High skewness ( \\(\\gamma = 2\\) for \\(\\lambda=1\\) ), requires \\(n \\geq 30\\) for normality. Binomial : Moderate skewness, converges by \\(n=30\\) . Variance Impact : The sampling distribution\u2019s variance is: $$ \\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n} $$ Uniform has the largest \\(\\sigma^2 = 8.333\\) , followed by Binomial ( \\(\\sigma^2 = 2.5\\) ), then Exponential ( \\(\\sigma^2 = 1\\) ). Larger \\(n\\) reduces \\(\\text{Var}(\\bar{X})\\) , tightening the distribution. Convergence Rate : Skewed distributions (Exponential) converge slower than symmetric ones (Uniform, Binomial). Practical Applications Estimating Population Parameters : The CLT justifies using \\(\\bar{X} \\sim \\mathcal{N}(\\mu, \\sigma^2/n)\\) for confidence intervals in surveys (e.g., estimating average income). Quality Control : In manufacturing, batch averages (e.g., screw lengths) are normally distributed, enabling statistical control charts. Financial Modeling : The CLT supports modeling average portfolio returns as normal, facilitating risk analysis despite non-normal asset returns. Discussion The simulations validate the CLT: the sampling distribution of \\(\\bar{X}\\) approaches \\(\\mathcal{N}(\\mu, \\sigma^2/n)\\) as \\(n\\) increases. The rate of convergence depends on population skewness, with symmetric distributions converging faster. The variance \\(\\frac{\\sigma^2}{n}\\) decreases with larger \\(n\\) , enhancing estimation precision. These results align with theoretical expectations and highlight the CLT\u2019s critical role in statistical inference across domains like polling, manufacturing, and finance.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"Simulation","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#markdown-document-exploring-the-central-limit-theorem-through-simulations","text":"","title":"Markdown Document: Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective","text":"The Central Limit Theorem (CLT) states that the distribution of the sample mean \\(\\bar{X}\\) of a random sample of size \\(n\\) from a population with mean \\(\\mu\\) and variance \\(\\sigma^2\\) approaches a normal distribution as \\(n\\) increases, regardless of the population\u2019s distribution. This project aims to: 1. Simulate sampling distributions for different population distributions. 2. Visualize the convergence of sample means to a normal distribution. 3. Explore the influence of population shape and variance on convergence. 4. Discuss real-world applications of the CLT.","title":"Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#methodology","text":"Population Distributions : Uniform : Continuous on \\([0, 10]\\) . Exponential : Right-skewed with rate parameter \\(\\lambda = 1\\) . Binomial : Discrete with \\(n=10\\) , \\(p=0.5\\) . Generate a population of size \\(N = 100,000\\) for each. Sampling and Visualization : Draw random samples of sizes \\(n = 5, 10, 30, 50\\) . Compute sample means for \\(M = 10,000\\) samples. Plot histograms of sample means with a kernel density estimate (KDE) and overlay the theoretical normal distribution. Parameter Exploration : Analyze how population skewness and variance affect convergence. Verify the sampling distribution\u2019s variance. Practical Applications : Estimating population parameters. Quality control in manufacturing. Financial modeling.","title":"Methodology"},{"location":"1%20Physics/6%20Statistics/Problem_1/#key-formulas","text":"","title":"Key Formulas"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population-parameters","text":"For each distribution, the mean \\(\\mu\\) and variance \\(\\sigma^2\\) are: - Uniform ( \\(a = 0\\) , \\(b = 10\\) ): $$ \\mu = \\frac{a + b}{2} = \\frac{0 + 10}{2} = 5 $$ $$ \\sigma^2 = \\frac{(b - a)^2}{12} = \\frac{(10 - 0)^2}{12} = \\frac{100}{12} \\approx 8.333 $$ - Exponential ( \\(\\lambda = 1\\) ): $$ \\mu = \\frac{1}{\\lambda} = \\frac{1}{1} = 1 $$ $$ \\sigma^2 = \\frac{1}{\\lambda^2} = \\frac{1}{1^2} = 1 $$ - Binomial ( \\(n = 10\\) , \\(p = 0.5\\) ): $$ \\mu = n \\cdot p = 10 \\cdot 0.5 = 5 $$ $$ \\sigma^2 = n \\cdot p \\cdot (1 - p) = 10 \\cdot 0.5 \\cdot 0.5 = 2.5 $$","title":"Population Parameters"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sample-mean","text":"For a sample of size \\(n\\) , the sample mean is: $$ \\bar{X} = \\frac{1}{n} \\sum_{i=1}^n X_i $$","title":"Sample Mean"},{"location":"1%20Physics/6%20Statistics/Problem_1/#central-limit-theorem","text":"For a population with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , the CLT states that for large \\(n\\) , the sampling distribution of \\(\\bar{X}\\) is approximately: $$ \\bar{X} \\sim \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) $$ - Mean of the sampling distribution : $$ \\mathbb{E}(\\bar{X}) = \\mu $$ - Variance of the sampling distribution : $$ \\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n} $$ - Normal density function (for plotting): $$ f(x) = \\frac{1}{\\sqrt{2\\pi \\cdot \\frac{\\sigma^2}{n}}} \\exp\\left(-\\frac{(x - \\mu)^2}{2 \\cdot \\frac{\\sigma^2}{n}}\\right) $$","title":"Central Limit Theorem"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-implementation","text":"The following Python script simulates the sampling distributions, visualizes them with histograms, and compares empirical and theoretical variances. import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set random seed for reproducibility np.random.seed(42) # Parameters population_size = 100_000 # Population size (N) sample_sizes = [5, 10, 30, 50] # Sample sizes (n) num_samples = 10_000 # Number of samples (M) # Define populations with theoretical parameters populations = { 'Uniform': { 'data': np.random.uniform(0, 10, population_size), 'mean': 5, # (0 + 10) / 2 'variance': 100 / 12 # (10 - 0)^2 / 12 }, 'Exponential': { 'data': np.random.exponential(scale=1, size=population_size), 'mean': 1, # 1 / lambda, lambda = 1 'variance': 1 # 1 / lambda^2 }, 'Binomial': { 'data': np.random.binomial(n=10, p=0.5, size=population_size), 'mean': 5, # n * p = 10 * 0.5 'variance': 2.5 # n * p * (1 - p) } } # Function to simulate sampling and compute means def simulate_sampling(population, sample_size, num_samples): \"\"\"Generate sampling distribution of the mean.\"\"\" sample_means = [np.mean(np.random.choice(population, size=sample_size)) for _ in range(num_samples)] return np.array(sample_means) # Function to plot sampling distribution def plot_sampling_distribution(sample_means, mu, sigma, sample_size, dist_name): \"\"\"Plot histogram of sample means with theoretical normal curve.\"\"\" plt.figure(figsize=(5, 4)) sns.histplot(sample_means, bins=50, kde=True, stat='density', label='Sample Means') # Theoretical normal curve x = np.linspace(mu - 4*sigma, mu + 4*sigma, 100) plt.plot(x, 1/(sigma * np.sqrt(2*np.pi)) * np.exp(-(x-mu)**2/(2*sigma**2)), 'r--', label=f'Normal(\u03bc={mu}, \u03c3\u00b2={sigma**2:.3f})') plt.title(f'{dist_name}, n={sample_size}') plt.xlabel('Sample Mean') plt.ylabel('Density') plt.legend() plt.tight_layout() # Simulate, visualize, and analyze variances for dist_name, dist_info in populations.items(): population = dist_info['data'] mu = dist_info['mean'] pop_variance = dist_info['variance'] # Plot sampling distributions plt.figure(figsize=(15, 4)) for i, sample_size in enumerate(sample_sizes, 1): sample_means = simulate_sampling(population, sample_size, num_samples) sigma = np.sqrt(pop_variance / sample_size) plt.subplot(1, len(sample_sizes), i) plot_sampling_distribution(sample_means, mu, sigma, sample_size, dist_name) plt.suptitle(f'Sampling Distributions for {dist_name} Population') plt.show() # Variance comparison print(f\"\\n{dist_name} Distribution (\u03bc={mu}, \u03c3\u00b2={pop_variance:.3f}):\") for sample_size in sample_sizes: sample_means = simulate_sampling(population, sample_size, num_samples) empirical_variance = np.var(sample_means, ddof=1) theoretical_variance = pop_variance / sample_size print(f\"Sample Size {sample_size}: Empirical Var = {empirical_variance:.4f}, \" f\"Theoretical Var = {theoretical_variance:.4f}\")","title":"Python Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#expected-results","text":"Visualizations : For each distribution (Uniform, Exponential, Binomial), four histograms (for \\(n = 5, 10, 30, 50\\) ) display the sampling distribution of \\(\\bar{X}\\) . A red dashed line shows the theoretical normal distribution \\(\\mathcal{N}(\\mu, \\sigma^2/n)\\) . Uniform : Rapid convergence to normality by \\(n=10\\) due to symmetry. Exponential : Skewed at \\(n=5\\) , approximates normality by \\(n=30\\) . Binomial : Near-normal by \\(n=30\\) , reflecting moderate symmetry. Variance Analysis : Empirical variances of sample means closely match the theoretical \\(\\frac{\\sigma^2}{n}\\) . Example (Uniform, \\(\\sigma^2 = 8.333\\) ): $$ n=5: \\text{Var}(\\bar{X}) = \\frac{8.333}{5} \\approx 1.667 $$ $$ n=50: \\text{Var}(\\bar{X}) = \\frac{8.333}{50} \\approx 0.167 $$","title":"Expected Results"},{"location":"1%20Physics/6%20Statistics/Problem_1/#parameter-exploration","text":"Shape Influence : Uniform : Symmetrical, no skewness, converges quickly (by \\(n=10\\) ). Exponential : High skewness ( \\(\\gamma = 2\\) for \\(\\lambda=1\\) ), requires \\(n \\geq 30\\) for normality. Binomial : Moderate skewness, converges by \\(n=30\\) . Variance Impact : The sampling distribution\u2019s variance is: $$ \\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n} $$ Uniform has the largest \\(\\sigma^2 = 8.333\\) , followed by Binomial ( \\(\\sigma^2 = 2.5\\) ), then Exponential ( \\(\\sigma^2 = 1\\) ). Larger \\(n\\) reduces \\(\\text{Var}(\\bar{X})\\) , tightening the distribution. Convergence Rate : Skewed distributions (Exponential) converge slower than symmetric ones (Uniform, Binomial).","title":"Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#practical-applications","text":"Estimating Population Parameters : The CLT justifies using \\(\\bar{X} \\sim \\mathcal{N}(\\mu, \\sigma^2/n)\\) for confidence intervals in surveys (e.g., estimating average income). Quality Control : In manufacturing, batch averages (e.g., screw lengths) are normally distributed, enabling statistical control charts. Financial Modeling : The CLT supports modeling average portfolio returns as normal, facilitating risk analysis despite non-normal asset returns.","title":"Practical Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#discussion","text":"The simulations validate the CLT: the sampling distribution of \\(\\bar{X}\\) approaches \\(\\mathcal{N}(\\mu, \\sigma^2/n)\\) as \\(n\\) increases. The rate of convergence depends on population skewness, with symmetric distributions converging faster. The variance \\(\\frac{\\sigma^2}{n}\\) decreases with larger \\(n\\) , enhancing estimation precision. These results align with theoretical expectations and highlight the CLT\u2019s critical role in statistical inference across domains like polling, manufacturing, and finance.","title":"Discussion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Simulation Markdown Document: Estimating \u03c0 Using Monte Carlo Methods Objective Monte Carlo methods leverage randomness to estimate numerical values, such as \u03c0, through geometric probability. This project implements two approaches: 1. Circle-Based Method : Estimate \u03c0 using the ratio of random points inside a unit circle to those in a bounding square. 2. Buffon\u2019s Needle Method : Estimate \u03c0 based on the probability of a needle crossing parallel lines on a plane. The simulations demonstrate how randomness can approximate \u03c0, explore convergence rates, and compare computational efficiency, connecting probability, geometry, and computation. Part 1: Circle-Based Monte Carlo Method Theoretical Foundation Consider a unit circle (radius \\(r = 1\\) ) centered at the origin, inscribed in a square with side length 2 (spanning \\(x, y \\in [-1, 1]\\) ). - Area of the circle : $$ A_{\\text{circle}} = \\pi r^2 = \\pi \\cdot 1^2 = \\pi $$ - Area of the square : $$ A_{\\text{square}} = 2 \\cdot 2 = 4 $$ - Ratio of areas : $$ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} $$ If \\(N\\) random points are uniformly distributed in the square, and \\(N_{\\text{circle}}\\) fall inside the circle (where \\(x^2 + y^2 \\leq 1\\) ), the ratio approximates the area ratio: $$ \\frac{N_{\\text{circle}}}{N} \\approx \\frac{\\pi}{4} $$ Thus, the estimate for \u03c0 is: $$ \\pi \\approx 4 \\cdot \\frac{N_{\\text{circle}}}{N} $$ Simulation Generate \\(N\\) random points \\((x, y)\\) with \\(x, y \\sim \\text{Uniform}(-1, 1)\\) . Count points where \\(x^2 + y^2 \\leq 1\\) (inside the unit circle). Estimate \u03c0 using the formula above. Test with \\(N = 10^3, 10^4, 10^5, 10^6\\) . Visualization Plot points, coloring those inside the circle (e.g., blue) and outside (e.g., red). Include the unit circle boundary for reference. Analysis Compute the error \\(|\\hat{\\pi} - \\pi|\\) for different \\(N\\) . Analyze convergence rate and computational efficiency. Part 2: Buffon\u2019s Needle Method Theoretical Foundation Buffon\u2019s Needle problem involves dropping a needle of length \\(l\\) onto a plane with parallel lines spaced \\(d\\) units apart ( \\(l \\leq d\\) ). - Setup : Assume \\(d = 1\\) , \\(l = 1\\) . - Parameters : - \\(x\\) : Distance from the needle\u2019s center to the nearest line, \\(x \\sim \\text{Uniform}(0, \\frac{d}{2}) = \\text{Uniform}(0, 0.5)\\) . - \\(\\theta\\) : Angle of the needle relative to the lines, \\(\\theta \\sim \\text{Uniform}(0, \\pi)\\) . - Crossing condition : A needle crosses a line if: $$ x \\leq \\frac{l}{2} \\sin(\\theta) = \\frac{1}{2} \\sin(\\theta) $$ - Probability of crossing : $$ P(\\text{cross}) = \\frac{2l}{\\pi d} = \\frac{2 \\cdot 1}{\\pi \\cdot 1} = \\frac{2}{\\pi} $$ - Derivation : $$ P(\\text{cross}) = \\int_0^{\\pi} \\int_0^{\\frac{l}{2} \\sin(\\theta)} \\frac{1}{\\frac{d}{2}} \\cdot \\frac{1}{\\pi} \\, dx \\, d\\theta = \\int_0^{\\pi} \\frac{\\frac{l}{2} \\sin(\\theta)}{\\frac{d}{2}} \\cdot \\frac{1}{\\pi} \\, d\\theta = \\frac{l}{\\pi d} \\int_0^{\\pi} \\sin(\\theta) \\, d\\theta = \\frac{l}{\\pi d} \\cdot 2 = \\frac{2l}{\\pi d} $$ - Estimation : For \\(N\\) needle drops, with \\(N_{\\text{cross}}\\) crossings: $$ \\frac{N_{\\text{cross}}}{N} \\approx \\frac{2}{\\pi} $$ $$ \\pi \\approx \\frac{2N}{N_{\\text{cross}}} $$ Simulation Drop \\(N\\) needles with random \\(x \\sim \\text{Uniform}(0, 0.5)\\) , \\(\\theta \\sim \\text{Uniform}(0, \\pi)\\) . Count crossings where \\(x \\leq \\frac{1}{2} \\sin(\\theta)\\) . Estimate \u03c0 using the formula above. Test with \\(N = 10^3, 10^4, 10^5, 10^6\\) . Visualization Plot needles (line segments) relative to parallel lines, coloring crossing needles differently. Analysis Compute the error \\(|\\hat{\\pi} - \\pi|\\) . Compare convergence rate with the circle-based method. Python Implementation The script implements both methods, generates visualizations, and analyzes convergence. import numpy as np import matplotlib.pyplot as plt # Set random seed for reproducibility np.random.seed(42) # Parameters sample_sizes = [10**3, 10**4, 10**5, 10**6] true_pi = np.pi # --- Circle-Based Method --- def circle_monte_carlo(N): \"\"\"Estimate pi using circle method and return points for plotting.\"\"\" x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) distances = x**2 + y**2 inside = distances <= 1 pi_estimate = 4 * np.sum(inside) / N return pi_estimate, x, y, inside # --- Buffon's Needle Method --- def buffon_needle(N): \"\"\"Estimate pi using Buffon's Needle method and return needle positions.\"\"\" x = np.random.uniform(0, 0.5, N) # Distance to nearest line theta = np.random.uniform(0, np.pi, N) # Angle crosses = x <= 0.5 * np.sin(theta) pi_estimate = 2 * N / np.sum(crosses) if np.sum(crosses) > 0 else np.inf return pi_estimate, x, theta, crosses # --- Convergence Analysis --- circle_errors = [] buffon_errors = [] for N in sample_sizes: # Circle method pi_circle, x, y, inside = circle_monte_carlo(N) circle_errors.append(abs(pi_circle - true_pi)) # Buffon method pi_buffon, x_buffon, theta, crosses = buffon_needle(N) buffon_errors.append(abs(pi_buffon - true_pi)) print(f\"N={N}: Circle \u03c0={pi_circle:.4f}, Error={circle_errors[-1]:.4f} | \" f\"Buffon \u03c0={pi_buffon:.4f}, Error={buffon_errors[-1]:.4f}\") # --- Visualization: Circle Method (for N=1000) --- pi_circle, x, y, inside = circle_monte_carlo(1000) plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], c='blue', s=10, label='Inside Circle') plt.scatter(x[~inside], y[~inside], c='red', s=10, label='Outside Circle') # Plot unit circle theta = np.linspace(0, 2*np.pi, 100) plt.plot(np.cos(theta), np.sin(theta), 'k-', label='Unit Circle') plt.gca().set_aspect('equal') plt.title(f'Circle Method (N=1000, \u03c0\u2248{pi_circle:.4f})') plt.xlabel('x') plt.ylabel('y') plt.legend() plt.show() # --- Visualization: Buffon's Needle (for N=100) --- pi_buffon, x, theta, crosses = buffon_needle(100) plt.figure(figsize=(10, 4)) for i in range(100): x_center = x[i] angle = theta[i] x_ends = [x_center - 0.5 * np.cos(angle), x_center + 0.5 * np.cos(angle)] y_ends = [0.5 * np.sin(angle), -0.5 * np.sin(angle)] color = 'blue' if crosses[i] else 'red' plt.plot(x_ends, y_ends, color, alpha=0.5) for line in [0, 1]: plt.axvline(line, color='black', linestyle='--') plt.title(f'Buffon\u2019s Needle (N=100, \u03c0\u2248{pi_buffon:.4f})') plt.xlabel('x') plt.ylabel('y') plt.xlim(-0.5, 1.5) plt.ylim(-0.75, 0.75) plt.gca().set_aspect('equal') plt.show() # --- Convergence Plot --- plt.figure(figsize=(8, 5)) plt.plot(sample_sizes, circle_errors, 'o-', label='Circle Method') plt.plot(sample_sizes, buffon_errors, 's-', label='Buffon\u2019s Needle') plt.xscale('log') plt.yscale('log') plt.xlabel('Number of Points/Drops (N)') plt.ylabel('Absolute Error |\u03c0 - \u03c0\u0302|') plt.title('Convergence of \u03c0 Estimates') plt.legend() plt.grid(True) plt.show() Expected Results Circle Method Visualization : Scatter plot with 1000 points: blue for inside the unit circle, red for outside, with the circle boundary in black. Example \u03c0 estimate (varies with seed): ~3.14 for \\(N=1000\\) . Buffon\u2019s Needle Visualization : Plot of 100 needles (line segments) between lines at \\(x=0, 1\\) , with crossing needles in blue, non-crossing in red. Example \u03c0 estimate: ~3.2 for \\(N=100\\) . Convergence Analysis : Printed output shows \u03c0 estimates and errors for \\(N = 10^3, 10^4, 10^5, 10^6\\) . Example (approximate, depends on seed): N=1000: Circle \u03c0=3.1360, Error=0.0056 | Buffon \u03c0=3.2258, Error=0.0843 N=10000: Circle \u03c0=3.1468, Error=0.0052 | Buffon \u03c0=3.1746, Error=0.0331 N=100000: Circle \u03c0=3.1402, Error=0.0014 | Buffon \u03c0=3.1410, Error=0.0006 N=1000000: Circle \u03c0=3.1419, Error=0.0003 | Buffon \u03c0=3.1421, Error=0.0005 Log-log plot shows error decreasing with \\(N\\) , roughly as \\(O(1/\\sqrt{N})\\) . Analysis Convergence Rate : Both methods exhibit Monte Carlo convergence: error scales as \\(O(1/\\sqrt{N})\\) , as variance of the estimate is proportional to \\(1/N\\) . Circle method typically converges faster due to a higher signal-to-noise ratio (area ratio is more stable than crossing probability). Accuracy : Circle method: Errors often <0.01 for \\(N \\geq 10^5\\) . Buffon\u2019s Needle: Larger variance in estimates, errors may exceed 0.05 for \\(N = 10^3\\) . Computational Efficiency : Circle method: Simple distance calculation ( \\(x^2 + y^2 \\leq 1\\) ), computationally lightweight. Buffon\u2019s Needle: Requires trigonometric computation ( \\(\\sin(\\theta)\\) ), slightly slower. Both scale linearly with \\(N\\) , but Buffon\u2019s Needle has higher variance, requiring more samples for similar accuracy. Discussion The circle-based method leverages a straightforward geometric ratio, making it intuitive and efficient. Buffon\u2019s Needle, while elegant, is less accurate due to the lower probability of crossings ( \\(2/\\pi \\approx 0.636\\) ), leading to higher variance. Both methods confirm Monte Carlo\u2019s power to approximate \u03c0 through randomness, with the circle method being more practical for high accuracy. These simulations highlight applications in physics (e.g., particle scattering), finance (e.g., option pricing), and computer science (e.g., randomized algorithms).","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"Simulation","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#markdown-document-estimating-using-monte-carlo-methods","text":"","title":"Markdown Document: Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#objective","text":"Monte Carlo methods leverage randomness to estimate numerical values, such as \u03c0, through geometric probability. This project implements two approaches: 1. Circle-Based Method : Estimate \u03c0 using the ratio of random points inside a unit circle to those in a bounding square. 2. Buffon\u2019s Needle Method : Estimate \u03c0 based on the probability of a needle crossing parallel lines on a plane. The simulations demonstrate how randomness can approximate \u03c0, explore convergence rates, and compare computational efficiency, connecting probability, geometry, and computation.","title":"Objective"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-circle-based-monte-carlo-method","text":"","title":"Part 1: Circle-Based Monte Carlo Method"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"Consider a unit circle (radius \\(r = 1\\) ) centered at the origin, inscribed in a square with side length 2 (spanning \\(x, y \\in [-1, 1]\\) ). - Area of the circle : $$ A_{\\text{circle}} = \\pi r^2 = \\pi \\cdot 1^2 = \\pi $$ - Area of the square : $$ A_{\\text{square}} = 2 \\cdot 2 = 4 $$ - Ratio of areas : $$ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} $$ If \\(N\\) random points are uniformly distributed in the square, and \\(N_{\\text{circle}}\\) fall inside the circle (where \\(x^2 + y^2 \\leq 1\\) ), the ratio approximates the area ratio: $$ \\frac{N_{\\text{circle}}}{N} \\approx \\frac{\\pi}{4} $$ Thus, the estimate for \u03c0 is: $$ \\pi \\approx 4 \\cdot \\frac{N_{\\text{circle}}}{N} $$","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation","text":"Generate \\(N\\) random points \\((x, y)\\) with \\(x, y \\sim \\text{Uniform}(-1, 1)\\) . Count points where \\(x^2 + y^2 \\leq 1\\) (inside the unit circle). Estimate \u03c0 using the formula above. Test with \\(N = 10^3, 10^4, 10^5, 10^6\\) .","title":"Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization","text":"Plot points, coloring those inside the circle (e.g., blue) and outside (e.g., red). Include the unit circle boundary for reference.","title":"Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#analysis","text":"Compute the error \\(|\\hat{\\pi} - \\pi|\\) for different \\(N\\) . Analyze convergence rate and computational efficiency.","title":"Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-buffons-needle-method","text":"","title":"Part 2: Buffon\u2019s Needle Method"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation_1","text":"Buffon\u2019s Needle problem involves dropping a needle of length \\(l\\) onto a plane with parallel lines spaced \\(d\\) units apart ( \\(l \\leq d\\) ). - Setup : Assume \\(d = 1\\) , \\(l = 1\\) . - Parameters : - \\(x\\) : Distance from the needle\u2019s center to the nearest line, \\(x \\sim \\text{Uniform}(0, \\frac{d}{2}) = \\text{Uniform}(0, 0.5)\\) . - \\(\\theta\\) : Angle of the needle relative to the lines, \\(\\theta \\sim \\text{Uniform}(0, \\pi)\\) . - Crossing condition : A needle crosses a line if: $$ x \\leq \\frac{l}{2} \\sin(\\theta) = \\frac{1}{2} \\sin(\\theta) $$ - Probability of crossing : $$ P(\\text{cross}) = \\frac{2l}{\\pi d} = \\frac{2 \\cdot 1}{\\pi \\cdot 1} = \\frac{2}{\\pi} $$ - Derivation : $$ P(\\text{cross}) = \\int_0^{\\pi} \\int_0^{\\frac{l}{2} \\sin(\\theta)} \\frac{1}{\\frac{d}{2}} \\cdot \\frac{1}{\\pi} \\, dx \\, d\\theta = \\int_0^{\\pi} \\frac{\\frac{l}{2} \\sin(\\theta)}{\\frac{d}{2}} \\cdot \\frac{1}{\\pi} \\, d\\theta = \\frac{l}{\\pi d} \\int_0^{\\pi} \\sin(\\theta) \\, d\\theta = \\frac{l}{\\pi d} \\cdot 2 = \\frac{2l}{\\pi d} $$ - Estimation : For \\(N\\) needle drops, with \\(N_{\\text{cross}}\\) crossings: $$ \\frac{N_{\\text{cross}}}{N} \\approx \\frac{2}{\\pi} $$ $$ \\pi \\approx \\frac{2N}{N_{\\text{cross}}} $$","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation_1","text":"Drop \\(N\\) needles with random \\(x \\sim \\text{Uniform}(0, 0.5)\\) , \\(\\theta \\sim \\text{Uniform}(0, \\pi)\\) . Count crossings where \\(x \\leq \\frac{1}{2} \\sin(\\theta)\\) . Estimate \u03c0 using the formula above. Test with \\(N = 10^3, 10^4, 10^5, 10^6\\) .","title":"Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization_1","text":"Plot needles (line segments) relative to parallel lines, coloring crossing needles differently.","title":"Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#analysis_1","text":"Compute the error \\(|\\hat{\\pi} - \\pi|\\) . Compare convergence rate with the circle-based method.","title":"Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-implementation","text":"The script implements both methods, generates visualizations, and analyzes convergence. import numpy as np import matplotlib.pyplot as plt # Set random seed for reproducibility np.random.seed(42) # Parameters sample_sizes = [10**3, 10**4, 10**5, 10**6] true_pi = np.pi # --- Circle-Based Method --- def circle_monte_carlo(N): \"\"\"Estimate pi using circle method and return points for plotting.\"\"\" x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) distances = x**2 + y**2 inside = distances <= 1 pi_estimate = 4 * np.sum(inside) / N return pi_estimate, x, y, inside # --- Buffon's Needle Method --- def buffon_needle(N): \"\"\"Estimate pi using Buffon's Needle method and return needle positions.\"\"\" x = np.random.uniform(0, 0.5, N) # Distance to nearest line theta = np.random.uniform(0, np.pi, N) # Angle crosses = x <= 0.5 * np.sin(theta) pi_estimate = 2 * N / np.sum(crosses) if np.sum(crosses) > 0 else np.inf return pi_estimate, x, theta, crosses # --- Convergence Analysis --- circle_errors = [] buffon_errors = [] for N in sample_sizes: # Circle method pi_circle, x, y, inside = circle_monte_carlo(N) circle_errors.append(abs(pi_circle - true_pi)) # Buffon method pi_buffon, x_buffon, theta, crosses = buffon_needle(N) buffon_errors.append(abs(pi_buffon - true_pi)) print(f\"N={N}: Circle \u03c0={pi_circle:.4f}, Error={circle_errors[-1]:.4f} | \" f\"Buffon \u03c0={pi_buffon:.4f}, Error={buffon_errors[-1]:.4f}\") # --- Visualization: Circle Method (for N=1000) --- pi_circle, x, y, inside = circle_monte_carlo(1000) plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], c='blue', s=10, label='Inside Circle') plt.scatter(x[~inside], y[~inside], c='red', s=10, label='Outside Circle') # Plot unit circle theta = np.linspace(0, 2*np.pi, 100) plt.plot(np.cos(theta), np.sin(theta), 'k-', label='Unit Circle') plt.gca().set_aspect('equal') plt.title(f'Circle Method (N=1000, \u03c0\u2248{pi_circle:.4f})') plt.xlabel('x') plt.ylabel('y') plt.legend() plt.show() # --- Visualization: Buffon's Needle (for N=100) --- pi_buffon, x, theta, crosses = buffon_needle(100) plt.figure(figsize=(10, 4)) for i in range(100): x_center = x[i] angle = theta[i] x_ends = [x_center - 0.5 * np.cos(angle), x_center + 0.5 * np.cos(angle)] y_ends = [0.5 * np.sin(angle), -0.5 * np.sin(angle)] color = 'blue' if crosses[i] else 'red' plt.plot(x_ends, y_ends, color, alpha=0.5) for line in [0, 1]: plt.axvline(line, color='black', linestyle='--') plt.title(f'Buffon\u2019s Needle (N=100, \u03c0\u2248{pi_buffon:.4f})') plt.xlabel('x') plt.ylabel('y') plt.xlim(-0.5, 1.5) plt.ylim(-0.75, 0.75) plt.gca().set_aspect('equal') plt.show() # --- Convergence Plot --- plt.figure(figsize=(8, 5)) plt.plot(sample_sizes, circle_errors, 'o-', label='Circle Method') plt.plot(sample_sizes, buffon_errors, 's-', label='Buffon\u2019s Needle') plt.xscale('log') plt.yscale('log') plt.xlabel('Number of Points/Drops (N)') plt.ylabel('Absolute Error |\u03c0 - \u03c0\u0302|') plt.title('Convergence of \u03c0 Estimates') plt.legend() plt.grid(True) plt.show()","title":"Python Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#expected-results","text":"Circle Method Visualization : Scatter plot with 1000 points: blue for inside the unit circle, red for outside, with the circle boundary in black. Example \u03c0 estimate (varies with seed): ~3.14 for \\(N=1000\\) . Buffon\u2019s Needle Visualization : Plot of 100 needles (line segments) between lines at \\(x=0, 1\\) , with crossing needles in blue, non-crossing in red. Example \u03c0 estimate: ~3.2 for \\(N=100\\) . Convergence Analysis : Printed output shows \u03c0 estimates and errors for \\(N = 10^3, 10^4, 10^5, 10^6\\) . Example (approximate, depends on seed): N=1000: Circle \u03c0=3.1360, Error=0.0056 | Buffon \u03c0=3.2258, Error=0.0843 N=10000: Circle \u03c0=3.1468, Error=0.0052 | Buffon \u03c0=3.1746, Error=0.0331 N=100000: Circle \u03c0=3.1402, Error=0.0014 | Buffon \u03c0=3.1410, Error=0.0006 N=1000000: Circle \u03c0=3.1419, Error=0.0003 | Buffon \u03c0=3.1421, Error=0.0005 Log-log plot shows error decreasing with \\(N\\) , roughly as \\(O(1/\\sqrt{N})\\) .","title":"Expected Results"},{"location":"1%20Physics/6%20Statistics/Problem_2/#analysis_2","text":"Convergence Rate : Both methods exhibit Monte Carlo convergence: error scales as \\(O(1/\\sqrt{N})\\) , as variance of the estimate is proportional to \\(1/N\\) . Circle method typically converges faster due to a higher signal-to-noise ratio (area ratio is more stable than crossing probability). Accuracy : Circle method: Errors often <0.01 for \\(N \\geq 10^5\\) . Buffon\u2019s Needle: Larger variance in estimates, errors may exceed 0.05 for \\(N = 10^3\\) . Computational Efficiency : Circle method: Simple distance calculation ( \\(x^2 + y^2 \\leq 1\\) ), computationally lightweight. Buffon\u2019s Needle: Requires trigonometric computation ( \\(\\sin(\\theta)\\) ), slightly slower. Both scale linearly with \\(N\\) , but Buffon\u2019s Needle has higher variance, requiring more samples for similar accuracy.","title":"Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#discussion","text":"The circle-based method leverages a straightforward geometric ratio, making it intuitive and efficient. Buffon\u2019s Needle, while elegant, is less accurate due to the lower probability of crossings ( \\(2/\\pi \\approx 0.636\\) ), leading to higher variance. Both methods confirm Monte Carlo\u2019s power to approximate \u03c0 through randomness, with the circle method being more practical for high accuracy. These simulations highlight applications in physics (e.g., particle scattering), finance (e.g., option pricing), and computer science (e.g., randomized algorithms).","title":"Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}