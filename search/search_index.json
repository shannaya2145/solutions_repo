{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Simulation Investigating the Range as a Function of the Angle of Projection Projectile motion is a classic problem in physics that combines simplicity with profound insights. Here, we analyze how the horizontal range of a projectile depends on its launch angle, derive the governing equations, explore parameter variations, and simulate the results computationally. 1. Theoretical Foundation Deriving the Equations of Motion Projectile motion occurs under constant gravitational acceleration, with no initial forces other than the launch impulse. Assuming a flat surface and neglecting air resistance, we start with Newton\u2019s second law in two dimensions (horizontal \\(x\\) and vertical \\(y\\) ): Horizontal motion : No acceleration ( \\(a_x = 0\\) ). $$ \\frac{d^2 x}{dt^2} = 0 $$ Initial conditions: \\(x(0) = 0\\) , \\(\\frac{dx}{dt}(0) = v_0 \\cos\\theta\\) , where \\(v_0\\) is the initial velocity and \\(\\theta\\) is the angle of projection. Solving: $$ x(t) = v_0 \\cos\\theta \\cdot t $$ Vertical motion : Constant acceleration ( \\(a_y = -g\\) ), where \\(g\\) is gravitational acceleration. $$ \\frac{d^2 y}{dt^2} = -g $$ Initial conditions: \\(y(0) = 0\\) , \\(\\frac{dy}{dt}(0) = v_0 \\sin\\theta\\) . Integrating twice: $$ \\frac{dy}{dt} = v_0 \\sin\\theta - g t $$ $$ y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$ These equations describe a parabolic trajectory, parameterized by \\(v_0\\) , \\(\\theta\\) , and \\(g\\) . Family of Solutions The solutions form a family parameterized by initial conditions: - \\(v_0\\) : Higher velocities stretch the parabola. - \\(\\theta\\) : Angles shift the balance between horizontal and vertical components. - \\(g\\) : Stronger gravity compresses the trajectory vertically. - Initial height ( \\(h\\) ): If \\(y(0) = h\\) , the equations adjust, affecting flight time and range. 2. Analysis of the Range Range as a Function of Angle The range \\(R\\) is the horizontal distance traveled when the projectile returns to \\(y = 0\\) . Set \\(y(t) = 0\\) : $$ 0 = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$ Factor out \\(t\\) : $$ t (v_0 \\sin\\theta - \\frac{1}{2} g t) = 0 $$ Solutions: \\(t = 0\\) (start) or \\(t = \\frac{2 v_0 \\sin\\theta}{g}\\) (landing time). Substitute into \\(x(t)\\) : $$ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} = \\frac{2 v_0^2 \\sin\\theta \\cos\\theta}{g} $$ Using the identity \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) : $$ R = \\frac{v_0^2 \\sin 2\\theta}{g} $$ - Maximum Range : \\(R\\) peaks when \\(\\sin 2\\theta = 1\\) , i.e., \\(2\\theta = 90^\\circ\\) , so \\(\\theta = 45^\\circ\\) . Then, \\(R_{\\text{max}} = \\frac{v_0^2}{g}\\) . - Symmetry : \\(\\theta\\) and \\(90^\\circ - \\theta\\) yield the same range (e.g., 30\u00b0 and 60\u00b0). Influence of Parameters Initial Velocity ( \\(v_0\\) ) : Range scales with \\(v_0^2\\) , amplifying the effect of angle. Gravity ( \\(g\\) ) : Higher \\(g\\) reduces \\(R\\) , compressing the trajectory. Launch Height : If \\(h > 0\\) , flight time increases, extending \\(R\\) . This requires solving a quadratic equation for \\(t\\) . 3. Practical Applications Sports : Optimizing a basketball shot or golf swing involves angle and velocity tuning. Engineering : Artillery and rocket launches adjust for terrain and air resistance. Astrophysics : Trajectories on other planets (different \\(g\\) ) follow the same principles. Uneven Terrain : Adjust the landing condition (e.g., \\(y = h_2\\) ) to model hills. Air Resistance : Introduce a drag term (proportional to velocity squared), requiring numerical solutions. 4. Implementation Below is a Python script to simulate and visualize the range versus angle: import numpy as np import matplotlib.pyplot as plt def calculate_range(v0, theta_deg, g=9.81, h=0): \"\"\"Calculate range given initial velocity, angle (degrees), gravity, and height.\"\"\" theta = np.radians(theta_deg) if h == 0: return (v0**2 * np.sin(2 * theta)) / g else: # For h > 0, solve quadratic for time: 0 = h + v0*sin(theta)*t - (1/2)*g*t^2 a = -0.5 * g b = v0 * np.sin(theta) c = h t = (-b + np.sqrt(b**2 - 4*a*c)) / (2*a) # Positive root return v0 * np.cos(theta) * t # Parameters v0_values = [10, 15, 20] # m/s g_values = [9.81, 3.71] # Earth, Mars h_values = [0, 5] # m angles = np.linspace(0, 90, 91) # 0\u00b0 to 90\u00b0 # Plotting plt.figure(figsize=(12, 8)) for v0 in v0_values: for g in g_values: for h in h_values: ranges = [calculate_range(v0, theta, g, h) for theta in angles] label = f\"v0={v0} m/s, g={g} m/s\u00b2, h={h} m\" plt.plot(angles, ranges, label=label) plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (meters)\") plt.title(\"Range vs. Angle of Projection\") plt.legend() plt.grid(True) plt.show() Output This generates a plot showing \\(R\\) versus \\(\\theta\\) for different \\(v_0\\) , \\(g\\) , and \\(h\\) . Key observations: - Peak at 45\u00b0 for \\(h = 0\\) . - Higher \\(v_0\\) increases range quadratically. - Lower \\(g\\) (e.g., Mars) extends range. - Non-zero \\(h\\) shifts the optimal angle below 45\u00b0. Limitations and Extensions Idealized Model : Assumes no air resistance, flat terrain, and constant \\(g\\) . Drag : Add \\(-k v^2\\) terms to the differential equations, solved numerically (e.g., Runge-Kutta). Wind : Introduce a velocity-dependent force. Terrain : Model \\(y_{\\text{ground}}(x)\\) and solve numerically for landing. Conclusion The range\u2019s dependence on \\(\\theta\\) reveals a beautiful symmetry and optimization problem, with \\(45^\\circ\\) as the sweet spot under ideal conditions. Variations in parameters enrich the model, bridging theory to real-world applications. The simulation highlights these relationships vividly, inviting further exploration into complex scenarios.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Simulation","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"Projectile motion is a classic problem in physics that combines simplicity with profound insights. Here, we analyze how the horizontal range of a projectile depends on its launch angle, derive the governing equations, explore parameter variations, and simulate the results computationally.","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deriving-the-equations-of-motion","text":"Projectile motion occurs under constant gravitational acceleration, with no initial forces other than the launch impulse. Assuming a flat surface and neglecting air resistance, we start with Newton\u2019s second law in two dimensions (horizontal \\(x\\) and vertical \\(y\\) ): Horizontal motion : No acceleration ( \\(a_x = 0\\) ). $$ \\frac{d^2 x}{dt^2} = 0 $$ Initial conditions: \\(x(0) = 0\\) , \\(\\frac{dx}{dt}(0) = v_0 \\cos\\theta\\) , where \\(v_0\\) is the initial velocity and \\(\\theta\\) is the angle of projection. Solving: $$ x(t) = v_0 \\cos\\theta \\cdot t $$ Vertical motion : Constant acceleration ( \\(a_y = -g\\) ), where \\(g\\) is gravitational acceleration. $$ \\frac{d^2 y}{dt^2} = -g $$ Initial conditions: \\(y(0) = 0\\) , \\(\\frac{dy}{dt}(0) = v_0 \\sin\\theta\\) . Integrating twice: $$ \\frac{dy}{dt} = v_0 \\sin\\theta - g t $$ $$ y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$ These equations describe a parabolic trajectory, parameterized by \\(v_0\\) , \\(\\theta\\) , and \\(g\\) .","title":"Deriving the Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"The solutions form a family parameterized by initial conditions: - \\(v_0\\) : Higher velocities stretch the parabola. - \\(\\theta\\) : Angles shift the balance between horizontal and vertical components. - \\(g\\) : Stronger gravity compresses the trajectory vertically. - Initial height ( \\(h\\) ): If \\(y(0) = h\\) , the equations adjust, affecting flight time and range.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-as-a-function-of-angle","text":"The range \\(R\\) is the horizontal distance traveled when the projectile returns to \\(y = 0\\) . Set \\(y(t) = 0\\) : $$ 0 = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 $$ Factor out \\(t\\) : $$ t (v_0 \\sin\\theta - \\frac{1}{2} g t) = 0 $$ Solutions: \\(t = 0\\) (start) or \\(t = \\frac{2 v_0 \\sin\\theta}{g}\\) (landing time). Substitute into \\(x(t)\\) : $$ R = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} = \\frac{2 v_0^2 \\sin\\theta \\cos\\theta}{g} $$ Using the identity \\(2 \\sin\\theta \\cos\\theta = \\sin 2\\theta\\) : $$ R = \\frac{v_0^2 \\sin 2\\theta}{g} $$ - Maximum Range : \\(R\\) peaks when \\(\\sin 2\\theta = 1\\) , i.e., \\(2\\theta = 90^\\circ\\) , so \\(\\theta = 45^\\circ\\) . Then, \\(R_{\\text{max}} = \\frac{v_0^2}{g}\\) . - Symmetry : \\(\\theta\\) and \\(90^\\circ - \\theta\\) yield the same range (e.g., 30\u00b0 and 60\u00b0).","title":"Range as a Function of Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-parameters","text":"Initial Velocity ( \\(v_0\\) ) : Range scales with \\(v_0^2\\) , amplifying the effect of angle. Gravity ( \\(g\\) ) : Higher \\(g\\) reduces \\(R\\) , compressing the trajectory. Launch Height : If \\(h > 0\\) , flight time increases, extending \\(R\\) . This requires solving a quadratic equation for \\(t\\) .","title":"Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Optimizing a basketball shot or golf swing involves angle and velocity tuning. Engineering : Artillery and rocket launches adjust for terrain and air resistance. Astrophysics : Trajectories on other planets (different \\(g\\) ) follow the same principles. Uneven Terrain : Adjust the landing condition (e.g., \\(y = h_2\\) ) to model hills. Air Resistance : Introduce a drag term (proportional to velocity squared), requiring numerical solutions.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Below is a Python script to simulate and visualize the range versus angle: import numpy as np import matplotlib.pyplot as plt def calculate_range(v0, theta_deg, g=9.81, h=0): \"\"\"Calculate range given initial velocity, angle (degrees), gravity, and height.\"\"\" theta = np.radians(theta_deg) if h == 0: return (v0**2 * np.sin(2 * theta)) / g else: # For h > 0, solve quadratic for time: 0 = h + v0*sin(theta)*t - (1/2)*g*t^2 a = -0.5 * g b = v0 * np.sin(theta) c = h t = (-b + np.sqrt(b**2 - 4*a*c)) / (2*a) # Positive root return v0 * np.cos(theta) * t # Parameters v0_values = [10, 15, 20] # m/s g_values = [9.81, 3.71] # Earth, Mars h_values = [0, 5] # m angles = np.linspace(0, 90, 91) # 0\u00b0 to 90\u00b0 # Plotting plt.figure(figsize=(12, 8)) for v0 in v0_values: for g in g_values: for h in h_values: ranges = [calculate_range(v0, theta, g, h) for theta in angles] label = f\"v0={v0} m/s, g={g} m/s\u00b2, h={h} m\" plt.plot(angles, ranges, label=label) plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (meters)\") plt.title(\"Range vs. Angle of Projection\") plt.legend() plt.grid(True) plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#output","text":"This generates a plot showing \\(R\\) versus \\(\\theta\\) for different \\(v_0\\) , \\(g\\) , and \\(h\\) . Key observations: - Peak at 45\u00b0 for \\(h = 0\\) . - Higher \\(v_0\\) increases range quadratically. - Lower \\(g\\) (e.g., Mars) extends range. - Non-zero \\(h\\) shifts the optimal angle below 45\u00b0.","title":"Output"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-and-extensions","text":"Idealized Model : Assumes no air resistance, flat terrain, and constant \\(g\\) . Drag : Add \\(-k v^2\\) terms to the differential equations, solved numerically (e.g., Runge-Kutta). Wind : Introduce a velocity-dependent force. Terrain : Model \\(y_{\\text{ground}}(x)\\) and solve numerically for landing.","title":"Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The range\u2019s dependence on \\(\\theta\\) reveals a beautiful symmetry and optimization problem, with \\(45^\\circ\\) as the sweet spot under ideal conditions. Variations in parameters enrich the model, bridging theory to real-world applications. The simulation highlights these relationships vividly, inviting further exploration into complex scenarios.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Simulation Investigating the Dynamics of a Forced Damped Pendulum The forced damped pendulum is a classic nonlinear system that exhibits a wide range of behaviors\u2014from simple oscillations to chaos\u2014due to the interplay of damping, gravitational restoring forces, and external periodic driving. This exploration bridges fundamental physics with computational modeling, offering insights into both theoretical principles and real-world applications. 1. Theoretical Foundation Governing Differential Equation The motion of a forced damped pendulum is described by a second-order nonlinear differential equation: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = F \\cos(\\omega_d t) $$ Where: - \\(\\theta\\) : Angular displacement (radians). - \\(b\\) : Damping coefficient (s\u207b\u00b9). - \\(g\\) : Gravitational acceleration (m/s\u00b2). - \\(L\\) : Pendulum length (m). - \\(F\\) : Driving force amplitude (s\u207b\u00b2). - \\(\\omega_d\\) : Driving frequency (rad/s). This equation balances angular acceleration, viscous damping, gravitational restoring force, and periodic forcing. Small-Angle Approximation For small \\(\\theta\\) , \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to a linear forced damped oscillator: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = F \\cos(\\omega_d t) $$ Where \\(\\omega_0 = \\sqrt{g/L}\\) is the natural frequency. The general solution is: - Homogeneous : \\(\\theta_h(t) = A e^{-\\frac{b}{2}t} \\cos(\\omega t + \\phi)\\) , with \\(\\omega = \\sqrt{\\omega_0^2 - (b/2)^2}\\) (underdamped case). Particular : \\(\\theta_p(t) = A_d \\cos(\\omega_d t - \\delta)\\) , where: $$ A_d = \\frac{F}{\\sqrt{(\\omega_0^2 - \\omega_d^2)^2 + (b \\omega_d)^2}}, \\quad \\delta = \\tan^{-1}\\left(\\frac{b \\omega_d}{\\omega_0^2 - \\omega_d^2}\\right) $$ Total : \\(\\theta(t) = \\theta_h(t) + \\theta_p(t)\\) . The transient ( \\(\\theta_h\\) ) decays, leaving the steady-state oscillation. Resonance Resonance occurs when \\(\\omega_d \\approx \\omega_0\\) , maximizing \\(A_d\\) . For light damping ( \\(b \\ll \\omega_0\\) ), the amplitude peaks sharply, amplifying energy input from the driving force. 2. Analysis of Dynamics Parameter Influence Damping ( \\(b\\) ) : Reduces amplitude and prevents unbounded growth at resonance. High \\(b\\) can suppress chaos. Driving Amplitude ( \\(F\\) ) : Small \\(F\\) yields periodic motion; large \\(F\\) can drive the system into chaos. Driving Frequency ( \\(\\omega_d\\) ) : Near \\(\\omega_0\\) , resonance amplifies motion. Far from \\(\\omega_0\\) , motion may become quasiperiodic or chaotic. Transition to Chaos Beyond small angles, the \\(\\sin\\theta\\) nonlinearity introduces complex dynamics: - Periodic Motion : At low \\(F\\) or \\(\\omega_d \\approx \\omega_0\\) , motion synchronizes with the drive. - Quasiperiodic Motion : Multiple incommensurate frequencies emerge as \\(F\\) increases. - Chaotic Motion : High \\(F\\) and specific \\(\\omega_d\\) lead to unpredictable, aperiodic behavior, sensitive to initial conditions. 3. Practical Applications Energy Harvesting : Oscillatory motion in piezoelectric devices converts mechanical energy to electricity. Suspension Bridges : External forces (wind) can induce resonant or chaotic vibrations, informing design. Circuits : Driven RLC circuits mirror this system, aiding oscillator design. 4. Implementation Python Simulation Below is a Python script using the Runge-Kutta (RK4) method to solve the nonlinear equation and visualize the dynamics: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # m/s\u00b2 L = 1.0 # m omega0 = np.sqrt(g / L) # Differential equation def pendulum(t, y, b, F, omega_d): theta, theta_dot = y return [theta_dot, -b * theta_dot - (g / L) * np.sin(theta) + F * np.cos(omega_d * t)] # Simulation function def simulate_pendulum(b, F, omega_d, t_max=50, theta0=0.1, theta_dot0=0): t_span = (0, t_max) t_eval = np.linspace(0, t_max, 1000) sol = solve_ivp(pendulum, t_span, [theta0, theta_dot0], args=(b, F, omega_d), method='RK45', t_eval=t_eval, rtol=1e-6) return sol.t, sol.y[0], sol.y[1] # Poincar\u00e9 section def poincare_section(t, theta, theta_dot, omega_d): period = 2 * np.pi / omega_d indices = np.where(np.mod(t, period) < 0.01)[0] # Sample at drive phase return theta[indices], theta_dot[indices] # Plotting plt.figure(figsize=(15, 10)) # Cases to explore cases = [ {\"b\": 0.1, \"F\": 0.5, \"omega_d\": omega0, \"label\": \"Resonance\"}, {\"b\": 0.5, \"F\": 1.2, \"omega_d\": 1.2, \"label\": \"Moderate Forcing\"}, {\"b\": 0.2, \"F\": 1.5, \"omega_d\": 1.4, \"label\": \"Chaotic\"} ] for i, case in enumerate(cases, 1): t, theta, theta_dot = simulate_pendulum(case[\"b\"], case[\"F\"], case[\"omega_d\"]) # Time series plt.subplot(3, 3, i) plt.plot(t, theta, 'b-', lw=1) plt.title(f\"{case['label']} (b={case['b']}, F={case['F']}, \u03c9d={case['omega_d']:.1f})\") plt.xlabel(\"Time (s)\") plt.ylabel(\"\u03b8 (rad)\") # Phase portrait plt.subplot(3, 3, i + 3) plt.plot(theta, theta_dot, 'r-', lw=0.5) plt.title(\"Phase Portrait\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") # Poincar\u00e9 section theta_p, theta_dot_p = poincare_section(t, theta, theta_dot, case[\"omega_d\"]) plt.subplot(3, 3, i + 6) plt.scatter(theta_p, theta_dot_p, s=5, c='k') plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") plt.tight_layout() plt.show() Output Description Time Series : Shows \\(\\theta(t)\\) for resonance (periodic), moderate forcing (quasiperiodic), and chaotic motion. Phase Portraits : Plots \\(\\theta\\) vs. \\(\\dot{\\theta}\\) , revealing closed loops (periodic), layered patterns (quasiperiodic), or dense filling (chaotic). Poincar\u00e9 Sections : Samples at the driving period, showing points clustering (periodic), forming curves (quasiperiodic), or scattering (chaotic). Deliverables General Solutions Small Angles : Linear solution with decaying transient and steady-state oscillation. Nonlinear : Numerical solutions reveal periodic, quasiperiodic, or chaotic regimes depending on parameters. Graphical Representations Resonance ( \\(b=0.1, F=0.5, \\omega_d=\\omega_0\\) ) : Large, stable oscillations. Moderate Forcing ( \\(b=0.5, F=1.2, \\omega_d=1.2\\) ) : Complex but bounded motion. Chaotic ( \\(b=0.2, F=1.5, \\omega_d=1.4\\) ) : erratic, unpredictable swings. Limitations and Extensions Limitations : Assumes constant \\(b\\) , periodic forcing, and no friction irregularities. Extensions : Add nonlinear damping ( \\(b |\\dot{\\theta}|\\) ), stochastic forcing, or multi-pendulum coupling. Visualizations Phase Portraits : Illustrate dynamic complexity. Poincar\u00e9 Sections : Highlight transitions to chaos. Bifurcation Diagrams : Plot max \\(\\theta\\) vs. \\(F\\) or \\(\\omega_d\\) (requires additional coding). Conclusion The forced damped pendulum reveals a spectrum of behaviors governed by damping, forcing amplitude, and frequency. This simulation captures its essence, from resonance to chaos, offering a window into nonlinear dynamics with broad applications.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Simulation","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"The forced damped pendulum is a classic nonlinear system that exhibits a wide range of behaviors\u2014from simple oscillations to chaos\u2014due to the interplay of damping, gravitational restoring forces, and external periodic driving. This exploration bridges fundamental physics with computational modeling, offering insights into both theoretical principles and real-world applications.","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-differential-equation","text":"The motion of a forced damped pendulum is described by a second-order nonlinear differential equation: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = F \\cos(\\omega_d t) $$ Where: - \\(\\theta\\) : Angular displacement (radians). - \\(b\\) : Damping coefficient (s\u207b\u00b9). - \\(g\\) : Gravitational acceleration (m/s\u00b2). - \\(L\\) : Pendulum length (m). - \\(F\\) : Driving force amplitude (s\u207b\u00b2). - \\(\\omega_d\\) : Driving frequency (rad/s). This equation balances angular acceleration, viscous damping, gravitational restoring force, and periodic forcing.","title":"Governing Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small \\(\\theta\\) , \\(\\sin\\theta \\approx \\theta\\) , simplifying the equation to a linear forced damped oscillator: $$ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = F \\cos(\\omega_d t) $$ Where \\(\\omega_0 = \\sqrt{g/L}\\) is the natural frequency. The general solution is: - Homogeneous : \\(\\theta_h(t) = A e^{-\\frac{b}{2}t} \\cos(\\omega t + \\phi)\\) , with \\(\\omega = \\sqrt{\\omega_0^2 - (b/2)^2}\\) (underdamped case). Particular : \\(\\theta_p(t) = A_d \\cos(\\omega_d t - \\delta)\\) , where: $$ A_d = \\frac{F}{\\sqrt{(\\omega_0^2 - \\omega_d^2)^2 + (b \\omega_d)^2}}, \\quad \\delta = \\tan^{-1}\\left(\\frac{b \\omega_d}{\\omega_0^2 - \\omega_d^2}\\right) $$ Total : \\(\\theta(t) = \\theta_h(t) + \\theta_p(t)\\) . The transient ( \\(\\theta_h\\) ) decays, leaving the steady-state oscillation.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance","text":"Resonance occurs when \\(\\omega_d \\approx \\omega_0\\) , maximizing \\(A_d\\) . For light damping ( \\(b \\ll \\omega_0\\) ), the amplitude peaks sharply, amplifying energy input from the driving force.","title":"Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameter-influence","text":"Damping ( \\(b\\) ) : Reduces amplitude and prevents unbounded growth at resonance. High \\(b\\) can suppress chaos. Driving Amplitude ( \\(F\\) ) : Small \\(F\\) yields periodic motion; large \\(F\\) can drive the system into chaos. Driving Frequency ( \\(\\omega_d\\) ) : Near \\(\\omega_0\\) , resonance amplifies motion. Far from \\(\\omega_0\\) , motion may become quasiperiodic or chaotic.","title":"Parameter Influence"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"Beyond small angles, the \\(\\sin\\theta\\) nonlinearity introduces complex dynamics: - Periodic Motion : At low \\(F\\) or \\(\\omega_d \\approx \\omega_0\\) , motion synchronizes with the drive. - Quasiperiodic Motion : Multiple incommensurate frequencies emerge as \\(F\\) increases. - Chaotic Motion : High \\(F\\) and specific \\(\\omega_d\\) lead to unpredictable, aperiodic behavior, sensitive to initial conditions.","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting : Oscillatory motion in piezoelectric devices converts mechanical energy to electricity. Suspension Bridges : External forces (wind) can induce resonant or chaotic vibrations, informing design. Circuits : Driven RLC circuits mirror this system, aiding oscillator design.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-simulation","text":"Below is a Python script using the Runge-Kutta (RK4) method to solve the nonlinear equation and visualize the dynamics: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.81 # m/s\u00b2 L = 1.0 # m omega0 = np.sqrt(g / L) # Differential equation def pendulum(t, y, b, F, omega_d): theta, theta_dot = y return [theta_dot, -b * theta_dot - (g / L) * np.sin(theta) + F * np.cos(omega_d * t)] # Simulation function def simulate_pendulum(b, F, omega_d, t_max=50, theta0=0.1, theta_dot0=0): t_span = (0, t_max) t_eval = np.linspace(0, t_max, 1000) sol = solve_ivp(pendulum, t_span, [theta0, theta_dot0], args=(b, F, omega_d), method='RK45', t_eval=t_eval, rtol=1e-6) return sol.t, sol.y[0], sol.y[1] # Poincar\u00e9 section def poincare_section(t, theta, theta_dot, omega_d): period = 2 * np.pi / omega_d indices = np.where(np.mod(t, period) < 0.01)[0] # Sample at drive phase return theta[indices], theta_dot[indices] # Plotting plt.figure(figsize=(15, 10)) # Cases to explore cases = [ {\"b\": 0.1, \"F\": 0.5, \"omega_d\": omega0, \"label\": \"Resonance\"}, {\"b\": 0.5, \"F\": 1.2, \"omega_d\": 1.2, \"label\": \"Moderate Forcing\"}, {\"b\": 0.2, \"F\": 1.5, \"omega_d\": 1.4, \"label\": \"Chaotic\"} ] for i, case in enumerate(cases, 1): t, theta, theta_dot = simulate_pendulum(case[\"b\"], case[\"F\"], case[\"omega_d\"]) # Time series plt.subplot(3, 3, i) plt.plot(t, theta, 'b-', lw=1) plt.title(f\"{case['label']} (b={case['b']}, F={case['F']}, \u03c9d={case['omega_d']:.1f})\") plt.xlabel(\"Time (s)\") plt.ylabel(\"\u03b8 (rad)\") # Phase portrait plt.subplot(3, 3, i + 3) plt.plot(theta, theta_dot, 'r-', lw=0.5) plt.title(\"Phase Portrait\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") # Poincar\u00e9 section theta_p, theta_dot_p = poincare_section(t, theta, theta_dot, case[\"omega_d\"]) plt.subplot(3, 3, i + 6) plt.scatter(theta_p, theta_dot_p, s=5, c='k') plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"\u03b8 (rad)\") plt.ylabel(\"d\u03b8/dt (rad/s)\") plt.tight_layout() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#output-description","text":"Time Series : Shows \\(\\theta(t)\\) for resonance (periodic), moderate forcing (quasiperiodic), and chaotic motion. Phase Portraits : Plots \\(\\theta\\) vs. \\(\\dot{\\theta}\\) , revealing closed loops (periodic), layered patterns (quasiperiodic), or dense filling (chaotic). Poincar\u00e9 Sections : Samples at the driving period, showing points clustering (periodic), forming curves (quasiperiodic), or scattering (chaotic).","title":"Output Description"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#deliverables","text":"","title":"Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#general-solutions","text":"Small Angles : Linear solution with decaying transient and steady-state oscillation. Nonlinear : Numerical solutions reveal periodic, quasiperiodic, or chaotic regimes depending on parameters.","title":"General Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#graphical-representations","text":"Resonance ( \\(b=0.1, F=0.5, \\omega_d=\\omega_0\\) ) : Large, stable oscillations. Moderate Forcing ( \\(b=0.5, F=1.2, \\omega_d=1.2\\) ) : Complex but bounded motion. Chaotic ( \\(b=0.2, F=1.5, \\omega_d=1.4\\) ) : erratic, unpredictable swings.","title":"Graphical Representations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations-and-extensions","text":"Limitations : Assumes constant \\(b\\) , periodic forcing, and no friction irregularities. Extensions : Add nonlinear damping ( \\(b |\\dot{\\theta}|\\) ), stochastic forcing, or multi-pendulum coupling.","title":"Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visualizations","text":"Phase Portraits : Illustrate dynamic complexity. Poincar\u00e9 Sections : Highlight transitions to chaos. Bifurcation Diagrams : Plot max \\(\\theta\\) vs. \\(F\\) or \\(\\omega_d\\) (requires additional coding).","title":"Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum reveals a spectrum of behaviors governed by damping, forcing amplitude, and frequency. This simulation captures its essence, from resonance to chaos, offering a window into nonlinear dynamics with broad applications.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Simulation Orbital Period and Orbital Radius: Exploring Kepler's Third Law Kepler's Third Law is a fundamental principle in celestial mechanics that links the square of a body\u2019s orbital period ( \\(T^2\\) ) to the cube of its orbital radius ( \\(r^3\\) ). This relationship provides valuable insights into gravitational interactions and forms the basis of our understanding of orbits, including satellites and exoplanets. In this section, we derive this law for circular orbits, examine its implications, analyze real-world examples, and simulate it using computational methods. 1. Theoretical Derivation Circular Orbits For a body in a circular orbit around a central mass \\(M\\) (e.g., a planet around a star), two forces balance: the gravitational force and the centripetal force required for circular motion. Gravitational Force : $$ F_g = \\frac{G M m}{r^2} $$ where \\(G\\) is the gravitational constant, \\(m\\) is the orbiting body\u2019s mass, and \\(r\\) is the orbital radius. Centripetal Force : $$ F_c = \\frac{m v^2}{r} $$ where \\(v\\) is the orbital velocity. Equating these: $$ \\frac{G M m}{r^2} = \\frac{m v^2}{r} $$ Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and simplify: $$ \\frac{G M}{r^2} = \\frac{v^2}{r} $$ $$ v^2 = \\frac{G M}{r} $$ The orbital period \\(T\\) is the time for one complete orbit, related to velocity by: $$ v = \\frac{2\\pi r}{T} $$ Square this: $$ v^2 = \\frac{4\\pi^2 r^2}{T^2} $$ Substitute into the force balance: $$ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} $$ Multiply through by \\(T^2\\) and divide by \\(r\\) : $$ 4\\pi^2 r^2 = \\frac{G M T^2}{r} $$ $$ T^2 = \\frac{4\\pi^2}{G M} r^3 $$ Thus: $$ T^2 = k r^3 $$ where \\(k = \\frac{4\\pi^2}{G M}\\) is a constant for a given central mass \\(M\\) . This is Kepler\u2019s Third Law for circular orbits. 2. Implications for Astronomy Planetary Masses : If \\(T\\) and \\(r\\) are measured for a satellite or moon, \\(M\\) of the central body can be calculated: $$ M = \\frac{4\\pi^2 r^3}{G T^2} $$ Distances : For known \\(M\\) (e.g., the Sun), measuring \\(T\\) determines \\(r\\) . System Consistency : The law holds across a planetary system, enabling comparisons (e.g., Earth vs. Mars orbits). 3. Real-World Examples Moon around Earth : \\(r \\approx 384,400\\) km = \\(3.844 \\times 10^8\\) m. \\(T \\approx 27.32\\) days = \\(2.36 \\times 10^6\\) s. \\(M_{\\text{Earth}} \\approx 5.972 \\times 10^{24}\\) kg. Check: \\(T^2 = (2.36 \\times 10^6)^2 \\approx 5.57 \\times 10^{12}\\) , \\(r^3 = (3.844 \\times 10^8)^3 \\approx 5.67 \\times 10^{25}\\) , ratio consistent with \\(k\\) . Earth around Sun : \\(r \\approx 1\\) AU = \\(1.496 \\times 10^{11}\\) m. \\(T \\approx 365.25\\) days = \\(3.156 \\times 10^7\\) s. \\(M_{\\text{Sun}} \\approx 1.989 \\times 10^{30}\\) kg. Verified similarly. 4. Implementation Python Simulation This script simulates circular orbits and plots \\(T^2\\) vs. \\(r^3\\) : import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m\u00b3 kg\u207b\u00b9 s\u207b\u00b2 M_sun = 1.989e30 # kg (Sun) M_earth = 5.972e24 # kg (Earth) # Orbital period function def orbital_period(r, M): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Data for simulation r_values = np.logspace(7, 11, 100) # 10^7 to 10^11 m T_sun = orbital_period(r_values, M_sun) / (24 * 3600) # Convert to days T_earth = orbital_period(r_values, M_earth) / (24 * 3600) # Real-world examples moon_r = 3.844e8 # m moon_T = 27.32 # days earth_r = 1.496e11 # m earth_T = 365.25 # days # Plotting plt.figure(figsize=(12, 6)) # Circular orbit visualization plt.subplot(1, 2, 1) theta = np.linspace(0, 2 * np.pi, 100) for r in [moon_r, earth_r / 100]: # Scaled for visibility x = r * np.cos(theta) y = r * np.sin(theta) plt.plot(x, y, lw=1) plt.plot(0, 0, 'yo', label=\"Central Mass\") plt.title(\"Circular Orbits (Scaled)\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.legend() plt.axis(\"equal\") # T\u00b2 vs r\u00b3 plt.subplot(1, 2, 2) plt.loglog(r_values**3, T_sun**2, 'b-', label=\"Sun (Planets)\") plt.loglog(r_values**3, T_earth**2, 'g-', label=\"Earth (Satellites)\") plt.loglog([moon_r**3], [moon_T**2], 'ro', label=\"Moon\") plt.loglog([earth_r**3], [earth_T**2], 'ko', label=\"Earth\") plt.title(\"T\u00b2 vs r\u00b3 (Kepler's Third Law)\") plt.xlabel(\"r\u00b3 (m\u00b3)\") plt.ylabel(\"T\u00b2 (days\u00b2)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() Output Description Left Plot : Scaled circular orbits (e.g., Moon, Earth-like) around a central mass. Right Plot : Log-log plot of \\(T^2\\) vs. \\(r^3\\) , showing linearity (slope 1) for Sun and Earth systems, with Moon and Earth data points overlaid. Deliverables Detailed Explanation Derivation : \\(T^2 \\propto r^3\\) arises from balancing gravitational and centripetal forces. Implications : Enables mass and distance calculations, foundational for astronomy. Graphical Representations Orbits : Visualizes circular paths. \\(T^2\\) vs. \\(r^3\\) : Confirms the law with real and simulated data. Extensions to Elliptical Orbits Kepler\u2019s Third Law generalizes to elliptical orbits using the semi-major axis \\(a\\) instead of \\(r\\) : $$ T^2 = \\frac{4\\pi^2}{G M} a^3 $$ This holds for planets, comets, and binary stars, with \\(a\\) as the average distance. The simulation could be extended by parameterizing elliptical paths. Conclusion Kepler\u2019s Third Law elegantly connects the orbital period to the radius, supported by both theory and simulation. Its applications range from lunar orbits to exoplanet discovery, with extensions to elliptical orbits expanding its scope.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Simulation","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius-exploring-keplers-third-law","text":"Kepler's Third Law is a fundamental principle in celestial mechanics that links the square of a body\u2019s orbital period ( \\(T^2\\) ) to the cube of its orbital radius ( \\(r^3\\) ). This relationship provides valuable insights into gravitational interactions and forms the basis of our understanding of orbits, including satellites and exoplanets. In this section, we derive this law for circular orbits, examine its implications, analyze real-world examples, and simulate it using computational methods.","title":"Orbital Period and Orbital Radius: Exploring Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-derivation","text":"","title":"1. Theoretical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#circular-orbits","text":"For a body in a circular orbit around a central mass \\(M\\) (e.g., a planet around a star), two forces balance: the gravitational force and the centripetal force required for circular motion. Gravitational Force : $$ F_g = \\frac{G M m}{r^2} $$ where \\(G\\) is the gravitational constant, \\(m\\) is the orbiting body\u2019s mass, and \\(r\\) is the orbital radius. Centripetal Force : $$ F_c = \\frac{m v^2}{r} $$ where \\(v\\) is the orbital velocity. Equating these: $$ \\frac{G M m}{r^2} = \\frac{m v^2}{r} $$ Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and simplify: $$ \\frac{G M}{r^2} = \\frac{v^2}{r} $$ $$ v^2 = \\frac{G M}{r} $$ The orbital period \\(T\\) is the time for one complete orbit, related to velocity by: $$ v = \\frac{2\\pi r}{T} $$ Square this: $$ v^2 = \\frac{4\\pi^2 r^2}{T^2} $$ Substitute into the force balance: $$ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} $$ Multiply through by \\(T^2\\) and divide by \\(r\\) : $$ 4\\pi^2 r^2 = \\frac{G M T^2}{r} $$ $$ T^2 = \\frac{4\\pi^2}{G M} r^3 $$ Thus: $$ T^2 = k r^3 $$ where \\(k = \\frac{4\\pi^2}{G M}\\) is a constant for a given central mass \\(M\\) . This is Kepler\u2019s Third Law for circular orbits.","title":"Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Planetary Masses : If \\(T\\) and \\(r\\) are measured for a satellite or moon, \\(M\\) of the central body can be calculated: $$ M = \\frac{4\\pi^2 r^3}{G T^2} $$ Distances : For known \\(M\\) (e.g., the Sun), measuring \\(T\\) determines \\(r\\) . System Consistency : The law holds across a planetary system, enabling comparisons (e.g., Earth vs. Mars orbits).","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"Moon around Earth : \\(r \\approx 384,400\\) km = \\(3.844 \\times 10^8\\) m. \\(T \\approx 27.32\\) days = \\(2.36 \\times 10^6\\) s. \\(M_{\\text{Earth}} \\approx 5.972 \\times 10^{24}\\) kg. Check: \\(T^2 = (2.36 \\times 10^6)^2 \\approx 5.57 \\times 10^{12}\\) , \\(r^3 = (3.844 \\times 10^8)^3 \\approx 5.67 \\times 10^{25}\\) , ratio consistent with \\(k\\) . Earth around Sun : \\(r \\approx 1\\) AU = \\(1.496 \\times 10^{11}\\) m. \\(T \\approx 365.25\\) days = \\(3.156 \\times 10^7\\) s. \\(M_{\\text{Sun}} \\approx 1.989 \\times 10^{30}\\) kg. Verified similarly.","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation","text":"This script simulates circular orbits and plots \\(T^2\\) vs. \\(r^3\\) : import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m\u00b3 kg\u207b\u00b9 s\u207b\u00b2 M_sun = 1.989e30 # kg (Sun) M_earth = 5.972e24 # kg (Earth) # Orbital period function def orbital_period(r, M): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Data for simulation r_values = np.logspace(7, 11, 100) # 10^7 to 10^11 m T_sun = orbital_period(r_values, M_sun) / (24 * 3600) # Convert to days T_earth = orbital_period(r_values, M_earth) / (24 * 3600) # Real-world examples moon_r = 3.844e8 # m moon_T = 27.32 # days earth_r = 1.496e11 # m earth_T = 365.25 # days # Plotting plt.figure(figsize=(12, 6)) # Circular orbit visualization plt.subplot(1, 2, 1) theta = np.linspace(0, 2 * np.pi, 100) for r in [moon_r, earth_r / 100]: # Scaled for visibility x = r * np.cos(theta) y = r * np.sin(theta) plt.plot(x, y, lw=1) plt.plot(0, 0, 'yo', label=\"Central Mass\") plt.title(\"Circular Orbits (Scaled)\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.legend() plt.axis(\"equal\") # T\u00b2 vs r\u00b3 plt.subplot(1, 2, 2) plt.loglog(r_values**3, T_sun**2, 'b-', label=\"Sun (Planets)\") plt.loglog(r_values**3, T_earth**2, 'g-', label=\"Earth (Satellites)\") plt.loglog([moon_r**3], [moon_T**2], 'ro', label=\"Moon\") plt.loglog([earth_r**3], [earth_T**2], 'ko', label=\"Earth\") plt.title(\"T\u00b2 vs r\u00b3 (Kepler's Third Law)\") plt.xlabel(\"r\u00b3 (m\u00b3)\") plt.ylabel(\"T\u00b2 (days\u00b2)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#output-description","text":"Left Plot : Scaled circular orbits (e.g., Moon, Earth-like) around a central mass. Right Plot : Log-log plot of \\(T^2\\) vs. \\(r^3\\) , showing linearity (slope 1) for Sun and Earth systems, with Moon and Earth data points overlaid.","title":"Output Description"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deliverables","text":"","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_1/#detailed-explanation","text":"Derivation : \\(T^2 \\propto r^3\\) arises from balancing gravitational and centripetal forces. Implications : Enables mass and distance calculations, foundational for astronomy.","title":"Detailed Explanation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graphical-representations","text":"Orbits : Visualizes circular paths. \\(T^2\\) vs. \\(r^3\\) : Confirms the law with real and simulated data.","title":"Graphical Representations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extensions-to-elliptical-orbits","text":"Kepler\u2019s Third Law generalizes to elliptical orbits using the semi-major axis \\(a\\) instead of \\(r\\) : $$ T^2 = \\frac{4\\pi^2}{G M} a^3 $$ This holds for planets, comets, and binary stars, with \\(a\\) as the average distance. The simulation could be extended by parameterizing elliptical paths.","title":"Extensions to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law elegantly connects the orbital period to the radius, supported by both theory and simulation. Its applications range from lunar orbits to exoplanet discovery, with extensions to elliptical orbits expanding its scope.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Escape velocity and cosmic velocities are essential concepts in astrophysics and space exploration. They describe the speeds necessary to overcome gravitational forces at different scales\u2014whether it involves escaping a planet, orbiting around it, or departing from a star system. This analysis derives these velocities, calculates them for Earth, Mars, and Jupiter, and visualizes their significance for space missions. 1. Definitions and Physical Meaning Escape Velocity ( \\(v_e\\) ) : The minimum speed an object must achieve to escape a celestial body\u2019s gravitational pull without further propulsion, assuming no atmospheric drag. It\u2019s the \"second cosmic velocity\" in the context of planetary escape. First Cosmic Velocity ( \\(v_1\\) ) : The orbital velocity for a circular orbit just above a planet\u2019s surface (ignoring atmosphere). It allows a satellite to maintain a low orbit. Second Cosmic Velocity ( \\(v_2\\) ) : Identical to escape velocity, it\u2019s the speed to escape a planet\u2019s gravity entirely from its surface. Third Cosmic Velocity ( \\(v_3\\) ) : The speed required to escape a star system (e.g., the Solar System) from a planet\u2019s orbit, accounting for both planetary and stellar gravitational potentials. 2. Mathematical Derivations Escape Velocity ( \\(v_e\\) or \\(v_2\\) ) Using conservation of energy: - Initial energy: Kinetic ( \\(\\frac{1}{2}mv_e^2\\) ) + Potential ( \\(-\\frac{GMm}{R}\\) ) = 0 (at infinity, total energy is zero). - At the surface ( \\(r = R\\) ): $$ \\frac{1}{2}mv_e^2 - \\frac{GMm}{R} = 0 $$ $$ v_e = \\sqrt{\\frac{2GM}{R}} $$ Where \\(G\\) is the gravitational constant, \\(M\\) is the body\u2019s mass, and \\(R\\) is its radius. First Cosmic Velocity ( \\(v_1\\) ) For a circular orbit at \\(r = R\\) , gravitational force equals centripetal force: $$ \\frac{GMm}{R^2} = \\frac{mv_1^2}{R} $$ $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Note: \\(v_e = \\sqrt{2} v_1\\) . Third Cosmic Velocity ( \\(v_3\\) ) This is the velocity to escape the Sun\u2019s gravity from a planet\u2019s orbit (e.g., Earth\u2019s distance from the Sun, \\(d\\) ). Total energy must be zero at infinity: - Initial: \\(\\frac{1}{2}mv_3^2 - \\frac{GM_{\\text{planet}}m}{R} - \\frac{GM_{\\text{sun}}m}{d}\\) . - At infinity: 0. Assuming launch from Earth\u2019s surface and simplifying (planet\u2019s orbit velocity contributes): $$ v_3 \\approx \\sqrt{v_e^2 + v_{\\text{esc,sun}}^2} $$ Where \\(v_{\\text{esc,sun}} = \\sqrt{\\frac{2GM_{\\text{sun}}}{d}}\\) . Practically, \\(v_3\\) is adjusted for orbital mechanics (e.g., Earth\u2019s orbital speed ~29.8 km/s adds complexity). 3. Calculations and Visualization Python Script This script calculates and plots \\(v_1\\) , \\(v_2\\) ( \\(v_e\\) ), and an approximate \\(v_3\\) for Earth, Mars, and Jupiter: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m\u00b3 kg\u207b\u00b9 s\u207b\u00b2 M_sun = 1.989e30 # kg # Celestial body data bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6.371e6, \"d\": 1.496e11}, # d = distance to Sun \"Mars\": {\"M\": 6.417e23, \"R\": 3.390e6, \"d\": 2.279e11}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 6.991e7, \"d\": 7.785e11} } # Functions def v1(M, R): return np.sqrt(G * M / R) / 1000 # km/s def v2(M, R): return np.sqrt(2 * G * M / R) / 1000 # km/s def v3_approx(M_planet, R, d): ve_planet = v2(M_planet, R) * 1000 # Back to m/s ve_sun = np.sqrt(2 * G * M_sun / d) # Escape from Sun at planet's orbit return (np.sqrt(ve_planet**2 + ve_sun**2)) / 1000 # km/s # Calculate velocities data = {} for body, params in bodies.items(): data[body] = { \"v1\": v1(params[\"M\"], params[\"R\"]), \"v2\": v2(params[\"M\"], params[\"R\"]), \"v3\": v3_approx(params[\"M\"], params[\"R\"], params[\"d\"]) } # Plotting plt.figure(figsize=(10, 6)) x = np.arange(len(bodies)) width = 0.25 plt.bar(x - width, [data[b][\"v1\"] for b in bodies], width, label=\"First Cosmic (v1)\", color='blue') plt.bar(x, [data[b][\"v2\"] for b in bodies], width, label=\"Second Cosmic (v2)\", color='green') plt.bar(x + width, [data[b][\"v3\"] for b in bodies], width, label=\"Third Cosmic (v3)\", color='red') plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Earth, Mars, and Jupiter\") plt.xticks(x, bodies.keys()) plt.legend() plt.grid(True, linestyle='--', alpha=0.7) plt.show() # Print values for body, velocities in data.items(): print(f\"{body}:\") print(f\" v1 = {velocities['v1']:.2f} km/s\") print(f\" v2 = {velocities['v2']:.2f} km/s\") print(f\" v3 = {velocities['v3']:.2f} km/s\") Output Earth : \\(v_1 \\approx 7.91\\) km/s, \\(v_2 \\approx 11.19\\) km/s, \\(v_3 \\approx 42.14\\) km/s. Mars : \\(v_1 \\approx 3.55\\) km/s, \\(v_2 \\approx 5.03\\) km/s, \\(v_3 \\approx 42.47\\) km/s. Jupiter : \\(v_1 \\approx 42.14\\) km/s, \\(v_2 \\approx 59.54\\) km/s, \\(v_3 \\approx 61.99\\) km/s. Graph : Bar chart comparing \\(v_1\\) , \\(v_2\\) , and \\(v_3\\) for each body. 4. Importance in Space Exploration Satellites ( \\(v_1\\) ) : Achieving \\(v_1\\) (e.g., 7.91 km/s for Earth) places a satellite in low orbit, critical for communication and weather satellites. Planetary Escape ( \\(v_2\\) ) : Rockets must exceed \\(v_2\\) (e.g., 11.19 km/s for Earth) to reach space or other planets, as in Apollo missions. Interstellar Travel ( \\(v_3\\) ) : \\(v_3\\) (e.g., 42.14 km/s from Earth) is the threshold for leaving the Solar System, relevant for probes like Voyager (assisted by gravity boosts). Deliverables Detailed Explanation \\(v_1\\) : Orbital speed at surface radius, dependent on \\(M\\) and \\(R\\) . \\(v_2\\) : Escape speed, \\(\\sqrt{2}\\) times \\(v_1\\) , scales with mass and inversely with radius. \\(v_3\\) : Combines planetary and solar escape, dominated by Sun\u2019s gravity at large \\(d\\) . Graphical Representation Bar chart shows \\(v_1 < v_2 < v_3\\) for each body, with Jupiter\u2019s high mass driving larger values, and Mars\u2019 smaller size yielding lower ones. Conclusion Escape and cosmic velocities play a crucial role in space exploration, determining the energy needed for achieving orbits and escapes. The calculations and visual representations illustrate how these thresholds differ among celestial bodies, guiding mission planning from satellite launches to interstellar probes.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"Escape velocity and cosmic velocities are essential concepts in astrophysics and space exploration. They describe the speeds necessary to overcome gravitational forces at different scales\u2014whether it involves escaping a planet, orbiting around it, or departing from a star system. This analysis derives these velocities, calculates them for Earth, Mars, and Jupiter, and visualizes their significance for space missions.","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-and-physical-meaning","text":"Escape Velocity ( \\(v_e\\) ) : The minimum speed an object must achieve to escape a celestial body\u2019s gravitational pull without further propulsion, assuming no atmospheric drag. It\u2019s the \"second cosmic velocity\" in the context of planetary escape. First Cosmic Velocity ( \\(v_1\\) ) : The orbital velocity for a circular orbit just above a planet\u2019s surface (ignoring atmosphere). It allows a satellite to maintain a low orbit. Second Cosmic Velocity ( \\(v_2\\) ) : Identical to escape velocity, it\u2019s the speed to escape a planet\u2019s gravity entirely from its surface. Third Cosmic Velocity ( \\(v_3\\) ) : The speed required to escape a star system (e.g., the Solar System) from a planet\u2019s orbit, accounting for both planetary and stellar gravitational potentials.","title":"1. Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations","text":"","title":"2. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocity-v_e-or-v_2","text":"Using conservation of energy: - Initial energy: Kinetic ( \\(\\frac{1}{2}mv_e^2\\) ) + Potential ( \\(-\\frac{GMm}{R}\\) ) = 0 (at infinity, total energy is zero). - At the surface ( \\(r = R\\) ): $$ \\frac{1}{2}mv_e^2 - \\frac{GMm}{R} = 0 $$ $$ v_e = \\sqrt{\\frac{2GM}{R}} $$ Where \\(G\\) is the gravitational constant, \\(M\\) is the body\u2019s mass, and \\(R\\) is its radius.","title":"Escape Velocity (\\(v_e\\) or \\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"For a circular orbit at \\(r = R\\) , gravitational force equals centripetal force: $$ \\frac{GMm}{R^2} = \\frac{mv_1^2}{R} $$ $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Note: \\(v_e = \\sqrt{2} v_1\\) .","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"This is the velocity to escape the Sun\u2019s gravity from a planet\u2019s orbit (e.g., Earth\u2019s distance from the Sun, \\(d\\) ). Total energy must be zero at infinity: - Initial: \\(\\frac{1}{2}mv_3^2 - \\frac{GM_{\\text{planet}}m}{R} - \\frac{GM_{\\text{sun}}m}{d}\\) . - At infinity: 0. Assuming launch from Earth\u2019s surface and simplifying (planet\u2019s orbit velocity contributes): $$ v_3 \\approx \\sqrt{v_e^2 + v_{\\text{esc,sun}}^2} $$ Where \\(v_{\\text{esc,sun}} = \\sqrt{\\frac{2GM_{\\text{sun}}}{d}}\\) . Practically, \\(v_3\\) is adjusted for orbital mechanics (e.g., Earth\u2019s orbital speed ~29.8 km/s adds complexity).","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-calculations-and-visualization","text":"","title":"3. Calculations and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-script","text":"This script calculates and plots \\(v_1\\) , \\(v_2\\) ( \\(v_e\\) ), and an approximate \\(v_3\\) for Earth, Mars, and Jupiter: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m\u00b3 kg\u207b\u00b9 s\u207b\u00b2 M_sun = 1.989e30 # kg # Celestial body data bodies = { \"Earth\": {\"M\": 5.972e24, \"R\": 6.371e6, \"d\": 1.496e11}, # d = distance to Sun \"Mars\": {\"M\": 6.417e23, \"R\": 3.390e6, \"d\": 2.279e11}, \"Jupiter\": {\"M\": 1.898e27, \"R\": 6.991e7, \"d\": 7.785e11} } # Functions def v1(M, R): return np.sqrt(G * M / R) / 1000 # km/s def v2(M, R): return np.sqrt(2 * G * M / R) / 1000 # km/s def v3_approx(M_planet, R, d): ve_planet = v2(M_planet, R) * 1000 # Back to m/s ve_sun = np.sqrt(2 * G * M_sun / d) # Escape from Sun at planet's orbit return (np.sqrt(ve_planet**2 + ve_sun**2)) / 1000 # km/s # Calculate velocities data = {} for body, params in bodies.items(): data[body] = { \"v1\": v1(params[\"M\"], params[\"R\"]), \"v2\": v2(params[\"M\"], params[\"R\"]), \"v3\": v3_approx(params[\"M\"], params[\"R\"], params[\"d\"]) } # Plotting plt.figure(figsize=(10, 6)) x = np.arange(len(bodies)) width = 0.25 plt.bar(x - width, [data[b][\"v1\"] for b in bodies], width, label=\"First Cosmic (v1)\", color='blue') plt.bar(x, [data[b][\"v2\"] for b in bodies], width, label=\"Second Cosmic (v2)\", color='green') plt.bar(x + width, [data[b][\"v3\"] for b in bodies], width, label=\"Third Cosmic (v3)\", color='red') plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Earth, Mars, and Jupiter\") plt.xticks(x, bodies.keys()) plt.legend() plt.grid(True, linestyle='--', alpha=0.7) plt.show() # Print values for body, velocities in data.items(): print(f\"{body}:\") print(f\" v1 = {velocities['v1']:.2f} km/s\") print(f\" v2 = {velocities['v2']:.2f} km/s\") print(f\" v3 = {velocities['v3']:.2f} km/s\")","title":"Python Script"},{"location":"1%20Physics/2%20Gravity/Problem_2/#output","text":"Earth : \\(v_1 \\approx 7.91\\) km/s, \\(v_2 \\approx 11.19\\) km/s, \\(v_3 \\approx 42.14\\) km/s. Mars : \\(v_1 \\approx 3.55\\) km/s, \\(v_2 \\approx 5.03\\) km/s, \\(v_3 \\approx 42.47\\) km/s. Jupiter : \\(v_1 \\approx 42.14\\) km/s, \\(v_2 \\approx 59.54\\) km/s, \\(v_3 \\approx 61.99\\) km/s. Graph : Bar chart comparing \\(v_1\\) , \\(v_2\\) , and \\(v_3\\) for each body.","title":"Output"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-importance-in-space-exploration","text":"Satellites ( \\(v_1\\) ) : Achieving \\(v_1\\) (e.g., 7.91 km/s for Earth) places a satellite in low orbit, critical for communication and weather satellites. Planetary Escape ( \\(v_2\\) ) : Rockets must exceed \\(v_2\\) (e.g., 11.19 km/s for Earth) to reach space or other planets, as in Apollo missions. Interstellar Travel ( \\(v_3\\) ) : \\(v_3\\) (e.g., 42.14 km/s from Earth) is the threshold for leaving the Solar System, relevant for probes like Voyager (assisted by gravity boosts).","title":"4. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables","text":"","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_2/#detailed-explanation","text":"\\(v_1\\) : Orbital speed at surface radius, dependent on \\(M\\) and \\(R\\) . \\(v_2\\) : Escape speed, \\(\\sqrt{2}\\) times \\(v_1\\) , scales with mass and inversely with radius. \\(v_3\\) : Combines planetary and solar escape, dominated by Sun\u2019s gravity at large \\(d\\) .","title":"Detailed Explanation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#graphical-representation","text":"Bar chart shows \\(v_1 < v_2 < v_3\\) for each body, with Jupiter\u2019s high mass driving larger values, and Mars\u2019 smaller size yielding lower ones.","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Escape and cosmic velocities play a crucial role in space exploration, determining the energy needed for achieving orbits and escapes. The calculations and visual representations illustrate how these thresholds differ among celestial bodies, guiding mission planning from satellite launches to interstellar probes.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Simulation Motivation When a payload is released from a moving rocket near Earth, its subsequent path is influenced by its initial velocity and direction, as well as Earth's gravitational force. Analyzing these trajectories is critical for space mission operations such as satellite deployment, reentry planning, or escape trajectories. Types of Trajectories Sub-orbital: The object follows a curved path and reenters Earth due to insufficient speed. Circular Orbit: The object moves at just the right speed to remain in a stable orbit at a fixed altitude. Elliptical Orbit: The object has enough speed to stay in orbit but follows an elliptical path. Escape Trajectory: The object has enough speed (greater than 11.2 km/s) to escape Earth\u2019s gravitational pull. Governing Equations The motion of the payload is determined by Newton's Law of Universal Gravitation: $$ F=\\frac{GMm}{r^2} $$ And the corresponding acceleration: $$ a=\\frac{GM}{R^2} $$ Where: G is the gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3\u00b7kg\u207b\u00b9\u00b7s\u207b\u00b2) M is Earth's mass (5.972 \u00d7 10\u00b2\u2074 kg) r is the distance from Earth's center Numerical Simulation Using Euler's method, the simulation updates the position and velocity of the payload over small time steps. The acceleration is recalculated at each step using the current position. Key steps include: Initialize position and velocity based on altitude, speed, and angle. Calculate gravitational acceleration at each step. Update velocity and position using Newtonian mechanics. Terminate if the payload impacts Earth or exceeds simulation time. Python Code The code simulates several scenarios to illustrate different trajectory types: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6371000 # Time step and duration dt = 1 t_max = 20000 def simulate_trajectory(v0, theta_deg, h0): theta = np.radians(theta_deg) r0 = R_earth + h0 x, y = r0 * np.cos(0), r0 * np.sin(0) vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x_list, y_list = [], [] for _ in np.arange(0, t_max, dt): r = np.sqrt(x**2 + y**2) if r < R_earth: break a = -G * M_earth / r**2 ax, ay = a * x / r, a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_list.append(x) y_list.append(y) return x_list, y_list scenarios = [ (7500, 0, 300000), (7800, 45, 300000), (11200, 0, 300000), (7900, 90, 300000), ] colors = ['b', 'g', 'r', 'purple'] labels = ['Sub-orbital', 'Elliptical', 'Escape', 'Circular'] plt.figure(figsize=(10,10)) for i, (v0, theta, h0) in enumerate(scenarios): x_traj, y_traj = simulate_trajectory(v0, theta, h0) plt.plot(x_traj, y_traj, label=labels[i], color=colors[i]) plt.gca().add_patch(plt.Circle((0,0), R_earth, color='gray', alpha=0.5)) plt.axis('equal') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.grid(True) plt.show() Conclusion This analysis highlights the critical importance of initial conditions in determining the fate of a payload. Whether it reenters, orbits, or escapes Earth depends entirely on its launch velocity and angle. The numerical model provides a powerful tool to visualize and predict these paths, aiding in mission planning and orbital mechanics studies.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"Simulation","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving rocket near Earth, its subsequent path is influenced by its initial velocity and direction, as well as Earth's gravitational force. Analyzing these trajectories is critical for space mission operations such as satellite deployment, reentry planning, or escape trajectories.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"Sub-orbital: The object follows a curved path and reenters Earth due to insufficient speed. Circular Orbit: The object moves at just the right speed to remain in a stable orbit at a fixed altitude. Elliptical Orbit: The object has enough speed to stay in orbit but follows an elliptical path. Escape Trajectory: The object has enough speed (greater than 11.2 km/s) to escape Earth\u2019s gravitational pull.","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-equations","text":"The motion of the payload is determined by Newton's Law of Universal Gravitation: $$ F=\\frac{GMm}{r^2} $$ And the corresponding acceleration: $$ a=\\frac{GM}{R^2} $$ Where: G is the gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3\u00b7kg\u207b\u00b9\u00b7s\u207b\u00b2) M is Earth's mass (5.972 \u00d7 10\u00b2\u2074 kg) r is the distance from Earth's center","title":"Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation","text":"Using Euler's method, the simulation updates the position and velocity of the payload over small time steps. The acceleration is recalculated at each step using the current position. Key steps include: Initialize position and velocity based on altitude, speed, and angle. Calculate gravitational acceleration at each step. Update velocity and position using Newtonian mechanics. Terminate if the payload impacts Earth or exceeds simulation time.","title":"Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code","text":"The code simulates several scenarios to illustrate different trajectory types: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_earth = 5.972e24 R_earth = 6371000 # Time step and duration dt = 1 t_max = 20000 def simulate_trajectory(v0, theta_deg, h0): theta = np.radians(theta_deg) r0 = R_earth + h0 x, y = r0 * np.cos(0), r0 * np.sin(0) vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x_list, y_list = [], [] for _ in np.arange(0, t_max, dt): r = np.sqrt(x**2 + y**2) if r < R_earth: break a = -G * M_earth / r**2 ax, ay = a * x / r, a * y / r vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_list.append(x) y_list.append(y) return x_list, y_list scenarios = [ (7500, 0, 300000), (7800, 45, 300000), (11200, 0, 300000), (7900, 90, 300000), ] colors = ['b', 'g', 'r', 'purple'] labels = ['Sub-orbital', 'Elliptical', 'Escape', 'Circular'] plt.figure(figsize=(10,10)) for i, (v0, theta, h0) in enumerate(scenarios): x_traj, y_traj = simulate_trajectory(v0, theta, h0) plt.plot(x_traj, y_traj, label=labels[i], color=colors[i]) plt.gca().add_patch(plt.Circle((0,0), R_earth, color='gray', alpha=0.5)) plt.axis('equal') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.grid(True) plt.show()","title":"Python Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"This analysis highlights the critical importance of initial conditions in determining the fate of a payload. Whether it reenters, orbits, or escapes Earth depends entirely on its launch velocity and angle. The numerical model provides a powerful tool to visualize and predict these paths, aiding in mission planning and orbital mechanics studies.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Simulation Introduction This report presents an investigation into the interference patterns formed by circular water waves emitted from multiple coherent point sources positioned at the vertices of a regular polygon. The objective is to analyze and visualize the resulting wave displacement patterns on the surface due to the principle of superposition. A square configuration was selected for this analysis, and all sources were assumed to emit waves with identical amplitude, wavelength, frequency, and initial phase. The resulting displacement field was computed and visualized using a Python simulation. 1. Theoretical Background The displacement of the water surface at a given point \\((x, y)\\) and time \\(t\\) from a single circular wave source located at \\((x_i, y_i)\\) is given by: \\[ \\eta_i(x, y, t) = A \\cos(k r_i - \\omega t) \\] where: \\(A\\) is the amplitude, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, \\(\\omega = 2\\pi f\\) is the angular frequency, \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the radial distance from the source to the point, and all sources are coherent (initial phase \\(\\phi = 0\\) ). The total displacement at a point due to \\(N\\) sources is the sum of the individual displacements: \\[ \\eta(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] 2. Source Configuration A regular square was chosen as the polygonal configuration. The square is centered at the origin and has a side length of \\(2a\\) . The coordinates of the four sources are: \\(S_1 = (-a, -a)\\) \\(S_2 = (-a, a)\\) \\(S_3 = (a, a)\\) \\(S_4 = (a, -a)\\) For simulation purposes, \\(a = 1.0\\) was used. 3. Simulation Method A 2D spatial grid was created to represent the water surface. For each point on the grid, the total displacement \\(\\eta(x, y, t)\\) was calculated by summing the contributions from all four sources. A snapshot at a fixed time \\(t = 0\\) was used to generate a contour plot of the displacement field. The Python code used for the simulation is shown below: import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude \u03bb = 1.0 # Wavelength f = 1.0 # Frequency k = 2 * np.pi / \u03bb # Wavenumber \u03c9 = 2 * np.pi * f # Angular frequency a = 1.0 # Half-side of square # Time snapshot t = 0 # Grid setup x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) # Source positions sources = [(-a, -a), (-a, a), (a, a), (a, -a)] # Superposition of waves eta = np.zeros_like(X) for (x0, y0) in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) eta += A * np.cos(k * R - \u03c9 * t) # Plotting plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta, levels=100, cmap='viridis') plt.colorbar(label='Displacement \u03b7(x, y, t)') plt.title('Interference Pattern from 4 Wave Sources (Square Configuration)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show() 4. Results and Discussion The resulting interference pattern exhibits symmetrical regions of constructive and destructive interference due to the coherent interaction of the waves. Key observations include: Constructive interference occurs at points where wavefronts from the sources arrive in phase, leading to higher amplitude regions (shown as bright bands or peaks). Destructive interference arises where the waves arrive out of phase, resulting in cancellation (dark nodes or lines). The overall pattern demonstrates square symmetry , reflecting the geometry of the source arrangement. The simulation effectively illustrates the spatial periodicity and complexity of interference patterns created by multiple circular wave sources. 5. Conclusion This study successfully demonstrates the use of mathematical modeling and numerical simulation to analyze the interference of circular waves from sources arranged in a regular polygon. The square configuration produced predictable, symmetric patterns, confirming theoretical expectations based on wave superposition. The methodology can be extended to other polygonal arrangements (e.g., triangle, pentagon) or adapted to include phase shifts, damping, and boundary effects for more realistic scenarios.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"Simulation","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#introduction","text":"This report presents an investigation into the interference patterns formed by circular water waves emitted from multiple coherent point sources positioned at the vertices of a regular polygon. The objective is to analyze and visualize the resulting wave displacement patterns on the surface due to the principle of superposition. A square configuration was selected for this analysis, and all sources were assumed to emit waves with identical amplitude, wavelength, frequency, and initial phase. The resulting displacement field was computed and visualized using a Python simulation.","title":"Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-theoretical-background","text":"The displacement of the water surface at a given point \\((x, y)\\) and time \\(t\\) from a single circular wave source located at \\((x_i, y_i)\\) is given by: \\[ \\eta_i(x, y, t) = A \\cos(k r_i - \\omega t) \\] where: \\(A\\) is the amplitude, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, \\(\\omega = 2\\pi f\\) is the angular frequency, \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the radial distance from the source to the point, and all sources are coherent (initial phase \\(\\phi = 0\\) ). The total displacement at a point due to \\(N\\) sources is the sum of the individual displacements: \\[ \\eta(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\]","title":"1. Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-source-configuration","text":"A regular square was chosen as the polygonal configuration. The square is centered at the origin and has a side length of \\(2a\\) . The coordinates of the four sources are: \\(S_1 = (-a, -a)\\) \\(S_2 = (-a, a)\\) \\(S_3 = (a, a)\\) \\(S_4 = (a, -a)\\) For simulation purposes, \\(a = 1.0\\) was used.","title":"2. Source Configuration"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-simulation-method","text":"A 2D spatial grid was created to represent the water surface. For each point on the grid, the total displacement \\(\\eta(x, y, t)\\) was calculated by summing the contributions from all four sources. A snapshot at a fixed time \\(t = 0\\) was used to generate a contour plot of the displacement field. The Python code used for the simulation is shown below: import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude \u03bb = 1.0 # Wavelength f = 1.0 # Frequency k = 2 * np.pi / \u03bb # Wavenumber \u03c9 = 2 * np.pi * f # Angular frequency a = 1.0 # Half-side of square # Time snapshot t = 0 # Grid setup x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) # Source positions sources = [(-a, -a), (-a, a), (a, a), (a, -a)] # Superposition of waves eta = np.zeros_like(X) for (x0, y0) in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) eta += A * np.cos(k * R - \u03c9 * t) # Plotting plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta, levels=100, cmap='viridis') plt.colorbar(label='Displacement \u03b7(x, y, t)') plt.title('Interference Pattern from 4 Wave Sources (Square Configuration)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.show()","title":"3. Simulation Method"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-results-and-discussion","text":"The resulting interference pattern exhibits symmetrical regions of constructive and destructive interference due to the coherent interaction of the waves. Key observations include: Constructive interference occurs at points where wavefronts from the sources arrive in phase, leading to higher amplitude regions (shown as bright bands or peaks). Destructive interference arises where the waves arrive out of phase, resulting in cancellation (dark nodes or lines). The overall pattern demonstrates square symmetry , reflecting the geometry of the source arrangement. The simulation effectively illustrates the spatial periodicity and complexity of interference patterns created by multiple circular wave sources.","title":"4. Results and Discussion"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-conclusion","text":"This study successfully demonstrates the use of mathematical modeling and numerical simulation to analyze the interference of circular waves from sources arranged in a regular polygon. The square configuration produced predictable, symmetric patterns, confirming theoretical expectations based on wave superposition. The methodology can be extended to other polygonal arrangements (e.g., triangle, pentagon) or adapted to include phase shifts, damping, and boundary effects for more realistic scenarios.","title":"5. Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Simulation","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"Simulation","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}